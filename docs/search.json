[
  {
    "objectID": "IF.html",
    "href": "IF.html",
    "title": "Integrate and Fire Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the integrate and fire (I&F) neuron model. We’ll investigate, in particular, how the spiking activity varies as we adjust the input current \\(I\\).\n\n1 Preliminaries\nBefore beginning, let’s load in the Python package we’ll need:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2 Numerical solutions - Introduction\nHow do we compute a numerical solution to the integrate and fire model? The basic idea is to rearrange the differential equation to get \\(V(t+1)\\) on the left hand side, and \\(V(t)\\) on the right hand side. Then, if we know what’s happening at time \\(t\\), we can solve for what’s happening at time \\(t+1\\).\nFor example, consider the differential equation:\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{I}{C}\n\\]\nIn words, we can think of:\n\\(dV\\) as the “change in voltage V”,\n\\(dt\\) as the “change in time t”.\nLet’s consider the case that we record the voltage \\(V\\) in discrete time steps. So we observe:\n\\(V[0], V[1], V[2], \\ldots\\)\nat times:\n\\(dt, \\, 2*dt, \\, 3*dt, \\ldots\\)\nwhere \\(dt\\) is the time between our samples of \\(V\\).\nWe can now write the “change in voltage V” as:\n\\[\n  dV = V(t+1) - V(t)\n\\]\nNotice that the change in voltage is the difference in V between two sequential time samples. Now, let’s rewrite \\(\\dfrac{dV}{dt}\\) as,\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt }\n\\]\nwhere we’ve replaced \\(dV\\). Now, let’s substitute this expression into the equation at the top of this file:\n\\[\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n\\]\nSolving this equation for \\(V(t+1)\\) you’ll find that:\n\\[\n  V(t+1) = V(t) + dt*(I/C)\n\\]\nNotice that, in this expression, we use our current value of the voltage V(t) and the model (I/C) to determine the next value of the voltage V(t+1).\nNow, let’s program this equation in Python. First, let’s set the values for the parameters \\(I\\) and \\(C\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe also need to set the value for \\(dt\\). This defines the time step for our model. We must choose it small enough so that we don’t miss anything interesting. We’ll choose:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s assume the units of time are seconds. So, we step forward in time by \\(0.01\\) s.\nThe right hand side of our equation is nearly defined, but we’re still missing one thing, \\(V(t)\\).\n\n\n\n\n\n\nQ: What value do we assign to \\(V(t)\\)?\n\n\n\nSo here’s an easier question: what initial value do we assign to \\(V(t)\\)?\nTo start, we’ll create an array of zeros to hold our results for \\(V\\):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis array V consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of V (i.e., step forward in time), in a way consistent with our model.\nLet’s choose an initial value for V of 0.2, which in our simple model we’ll assume represents the rest state.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Given the initial state V[0]=0.2, calculate V[1]. Then calcualte V[2].\n\n\n\nAfter the two calculations above, we’ve moved forward two time steps into the future, from \\(t=0\\) s to \\(t=0.01\\) s, and then from \\(t=0.01\\) s to \\(t=0.02\\) s. But what if we want to know \\(V\\) at \\(t=10\\) s? Then, this iteration-by-hand procedure becomes much too boring and error-prone. So, what do we do? Let’s make the computer do it …\n\n\n3 Numerical solutions - Implementation\nLet’s computerize this iteration-by-hand procedure to find V[999].\nTo do so, we’ll use a for-loop.\nHere’s what it looks like:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Does this loop make sense? Describe what’s happening here.\n\n\n\n\n\n\n\n\n\nQ: Why does the range command end at 999?\n\n\n\nExecute this for-loop and examine the results in vector V. To do so, let’s plot V:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What happens to the voltage after 1000 steps?\n\n\n\nThis plot is informative, but not great. Really, we’d like to plot the voltage as a function of time, not steps or indices. To do so, we need to define a time axis:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What’s happening in the command above? Does it make sense? (If not, trying printing or plotting t.)\n\n\n\nNow, with time defined, let’s redo the plot of the voltage with the axes labeled appropriately.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nFinally, let’s put it all together . . .\n\n\n4 I&F CODE (version 1)\nSo far, we constructed parts of the I&F model in bits-and-pieces. Let’s now collect all the code, compute a numerical solution to the I&F model, and plot the results (with appropriate axes).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=0? Can you set I so that V &gt; 20 within 10 s?\n\n\n\n\n\n5 Voltage threshold\nNotice, our model is missing something important: the reset.\n\n\n\n\n\n\nQ: Without the reset, how does the voltage behave as \\(t\\rightarrow\\infty\\) (if \\(I&gt;0\\))?\n\n\n\nNow, let’s update our model to include the reset. To do so, we’ll add two things to our code.\n\nFirst, we’ll define the voltage threshold Vth, and reset voltage Vreset.\nSecond, we’ll check to see if V exceeds Vth using an if-statement; if it does, then we’ll set V equal to Vreset.\n\n\n\n\n\n\n\nQ: How will you update the code below to include the reset?\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n6 I&F CODE (version 2)\nNow, let’s put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=10? If I=100?\n\n\n\n\n\n\n\n\n\nQ: Adjust the parameter C. What happens to V if C=0.1? If C=10?\n\n\n\n\n\n\n\n\n\nQ: What is “spiking” in this I&F model?\n\n\n\n\n\n\n7 Discussion\n\nDescribe the main components of the IF model. Draw it (in some way).\nDescribe the main components of the LIF model. Draw it (in some way).\nDescribe the differences and similarities between the IF and LIF models.\nThe IF model is meant to mimic a neurons activity. What is realistic about the IF model? What is unrealistic?\nDescribe the roles of the IF model parameters Vreset and Vthreshold.\nConsider the IF model. Sketch voltage (V) versus time (t) for a small input current, for a large input current.\n\nHow does an increase in capacitance (C) impact the dynamics?\nCan you interpret this physically?\n\nPlot the f-I curve for the IF model.\n\n\n\n\n8 Challenges\n\nConsider the LIF model. Plot (in Python) voltage (V) versus time (t) for a small input current, for a large input current.\nPerform numerical simulations to determine how doubling the capacitance (C) impacts the firing rate of the LIF model. Based on your numerical simulations, does the firing rate increase or decrease? Provide a physical explanation for your results (i.e., how does the charge move around the circuit to impact the firing rate?) HINT: Capacitance represents the capacity of a cell to hold charge.\nPerform numerical simulations to determine how doubling the resistance (R) impacts the firing rate of the LIF model. Based on your numerical simulations, does the firing rate increase or decrease? Provide a physical explanation for your results (i.e., how does the charge move around the circuit to impact the firing rate?) HINT: Higher resistance makes it harder for charge to flow in or out of the cell.\nDetermine how the firing rate of the LIF model varies with input I. Plot the firing rate versus I (i.e., plot the “f-I curve”).\nADVANCED. Simulate the Izhikevich neuron. Provide examples of two different types of spiking activity."
  },
  {
    "objectID": "Perceptron.html",
    "href": "Perceptron.html",
    "title": "Perceptron",
    "section": "",
    "text": "In this notebook, we will construct simple perceptron models. We’ll start by implementing a perceptron model, and seeing how it behaves. We’ll then outline the steps to train a perceptron to classify a point as above or below a line.\nThis discussion follows the excellent example and discussion at The Nature of Code. Please see that reference for additional details, and a more sophisticated coding strategy (using Classes in Python)."
  },
  {
    "objectID": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "href": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "title": "Perceptron",
    "section": "3.1 Provide perceptron with inputs and known answer.",
    "text": "3.1 Provide perceptron with inputs and known answer.\nFirst, let’s make a function that computes a line, and determines if a given y value is above or below the line. We’ll use this function to return the correct (“known”) answer. Having known answers is important for training the perceptron. We’ll use the known answers to tell the when it’s right or wrong (i.e., when the perceptron makes an error).\nLet’s define the function (known_answer) should take four inputs:\n\nslope\nintercept\nx\ny\n\nwhere the (x,y) value is a point we choose on the plane. The function should return one output:\n\ndesired_output\n\nwhere,\ndesired_output = 1, if the y value (the last input) is above the line,\ndesired_putput = 0, if the y value (the last input) is below the line.\nComplete the function below:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand the line with slope and intercept,\n\n\nslope = 2  intercept = 1\n\n\nIs the (x,y) point above or below the line?\n\n\n\nA: To answer this, let’s ask our function,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nA (Continued): We find a correct_answer of 1.\n\n\nSo, the point (x,y)=(0.7,3) is above the line with slope 2 and intercept 1."
  },
  {
    "objectID": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "href": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "title": "Perceptron",
    "section": "3.2 Ask perceptron to guess an answer.",
    "text": "3.2 Ask perceptron to guess an answer.\nOur next step is to compare our desired output (computed in Step 1) to the output guessed by the perceptron. To do so, we’ll need to compute the feedforward solution for the perceptron (i.e., given the inputs and bias, determine the perceptron output). Let’s do so complete the function below,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis function takes five inputs:\n\nx = the x coordinate of the point we choose in the plane.\ny = the y coordinate of the point we choose in the plane.\nwx = the weight of x input.\nwy = the weight of y input.\nwb = the weight of the bias.\n\nAnd this function returns one output:\n\nthe perceptron’s guess, is the point above (=1) or below (=0) the line.\n\n\n\n\n\n\n\nQ: Again consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand set initial values for the perceptron weights. Let’s just set these all to 0.5; our goal in the rest of this module will be to train the perceptron by adjusting these weights. But for now,\n\n\nwx,wy,wb = 0.5\n\n\nThen, ask the perceptron for it’s guess for it’s guess, is the point above or below the line?\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nA: We find a peceptron_guess of 1.\nSo, the perceptron guesses that the point (x,y)=(0.7,3) is above the line."
  },
  {
    "objectID": "Perceptron.html#compute-the-error.",
    "href": "Perceptron.html#compute-the-error.",
    "title": "Perceptron",
    "section": "3.3 Compute the error.",
    "text": "3.3 Compute the error.\nWe’ve now answered the question “Is the (x,y) point above the line?” in two ways:\n\nthe known answer, and\nthe perceptron’s guess.\n\nLet’s compute the error as the difference between these two answers:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What do you find for the error? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "href": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "title": "Perceptron",
    "section": "3.4 Adjust all weights according to the error.",
    "text": "3.4 Adjust all weights according to the error.\nTo update the weights, we’ll use the expression,\nnew weight = weight + error * input * learning constant\nWe need to compute this for each weight (wx, wy, wb).\nFirst, let’s set the learning constant,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThen, we can compute the new weights,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that, in the update to wb we use the fact that the bias equals 1.\n\n\n\n\n\n\nQ: What do you find for the new weights? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#return-to-step-1-and-repeat",
    "href": "Perceptron.html#return-to-step-1-and-repeat",
    "title": "Perceptron",
    "section": "3.5 Return to Step 1 and repeat …",
    "text": "3.5 Return to Step 1 and repeat …\nWe could try to compute these repetitions by hand, for example by repeating the cells above. To do so, we’d choose a new point in the (x,y) plane, determine whether it’s above the line 2x+1, ask the perceptron to guess whether it’s above the line, then use the error to update the perceptron’s weights.\nBut we want to evaluate this procedure 2000 times. Doing so by hand would be a total pain, and highly error prone. Instead, let’s ask the computer to do the boring work of multiple repetitions. To do so, let’s collect the code above, and examine 2000 (x,y) points chosen randomly in the plane. We’ll wrap our code above inside a for-loop to make this efficient,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "CFC_Lab.html",
    "href": "CFC_Lab.html",
    "title": "Cross-frequency coupling",
    "section": "",
    "text": "# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\n\nQ. Do you observe evidence of cross-frequency coupling?\n\n\n\n\n\n\n\n# Load the data.\ndata = loadmat('Data/LFP-1.mat')      # Load the data,\nt    = data['t'][0]                   # ... extract t, the time variable,\nLFP  = data['LFP'][0]                 # ... and LFP, the voltage variable.\ndt   = t[1] - t[0]                    # Define the sampling interval,\nfNQ  = 1 / dt / 2                     # ... and Nyquist frequency. \n\n\nplt.plot(t,LFP);\n\n\n\n\n\nQ. What rhythms are present in the data?\n\n\n\n\n\n\n\n# Compute the spectrum.\n\n\n\n\n\nQ. Filter the data into low and high frequency bands. What frequency bands will you choose?\nQ. Visualize the data; does the filtering make sense?\n\n\n\n\n\n\n\nfrom scipy import signal\n\n# Low frequency band.\nWn = [??,??];                       # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVlo = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data.\n\n# High frequency band.\nWn = [??, ??];                      # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVhi = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data.\n\n\n\n\n\nQ. How do you extract the amplitude and phase from the filtered signals?\nQ. For Vhi and Vlo, we need to compute the analytic signal, and then the phase or amplitude. What Python functions do you need?\nQ. Visualize the amplitude and phase; does it make sense?\n\n\n\n\n\n\n\n# Compute the amplitude and phase.\n\n\n\n\n\nQ. Determine if the phase and amplitude are related by making a phase-amplitude histogram. What is the value of the statistic h?\nQ. Does this result suggest CFC occurs in these data?\nQ. If no CFC occurred in the data, what would you expect to find in the plot of average amplitude versus phase?\n\n\n\n\n\n\n\n# Plot the amplitude-phase histogram."
  },
  {
    "objectID": "CFC_Lab.html#step-1-load-the-data-and-look-at-it.",
    "href": "CFC_Lab.html#step-1-load-the-data-and-look-at-it.",
    "title": "Cross-frequency coupling",
    "section": "",
    "text": "Q. Do you observe evidence of cross-frequency coupling?\n\n\n\n\n\n\n\n# Load the data.\ndata = loadmat('Data/LFP-1.mat')      # Load the data,\nt    = data['t'][0]                   # ... extract t, the time variable,\nLFP  = data['LFP'][0]                 # ... and LFP, the voltage variable.\ndt   = t[1] - t[0]                    # Define the sampling interval,\nfNQ  = 1 / dt / 2                     # ... and Nyquist frequency. \n\n\nplt.plot(t,LFP);"
  },
  {
    "objectID": "CFC_Lab.html#spectral-analysis",
    "href": "CFC_Lab.html#spectral-analysis",
    "title": "Cross-frequency coupling",
    "section": "",
    "text": "Q. What rhythms are present in the data?\n\n\n\n\n\n\n\n# Compute the spectrum."
  },
  {
    "objectID": "CFC_Lab.html#phase-amplitude-coupling-step-1",
    "href": "CFC_Lab.html#phase-amplitude-coupling-step-1",
    "title": "Cross-frequency coupling",
    "section": "",
    "text": "Q. Filter the data into low and high frequency bands. What frequency bands will you choose?\nQ. Visualize the data; does the filtering make sense?\n\n\n\n\n\n\n\nfrom scipy import signal\n\n# Low frequency band.\nWn = [??,??];                       # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVlo = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data.\n\n# High frequency band.\nWn = [??, ??];                      # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVhi = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data."
  },
  {
    "objectID": "CFC_Lab.html#phase-amplitude-coupling-step-2",
    "href": "CFC_Lab.html#phase-amplitude-coupling-step-2",
    "title": "Cross-frequency coupling",
    "section": "",
    "text": "Q. How do you extract the amplitude and phase from the filtered signals?\nQ. For Vhi and Vlo, we need to compute the analytic signal, and then the phase or amplitude. What Python functions do you need?\nQ. Visualize the amplitude and phase; does it make sense?\n\n\n\n\n\n\n\n# Compute the amplitude and phase."
  },
  {
    "objectID": "CFC_Lab.html#phase-amplitude-coupling-step-3",
    "href": "CFC_Lab.html#phase-amplitude-coupling-step-3",
    "title": "Cross-frequency coupling",
    "section": "",
    "text": "Q. Determine if the phase and amplitude are related by making a phase-amplitude histogram. What is the value of the statistic h?\nQ. Does this result suggest CFC occurs in these data?\nQ. If no CFC occurred in the data, what would you expect to find in the plot of average amplitude versus phase?\n\n\n\n\n\n\n\n# Plot the amplitude-phase histogram."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BU MA665 + MA666 (Fall 2025)",
    "section": "",
    "text": "MA665\n\nIntroduction\n\nRead the syllabus\nRead: Wilson et al, Good enough practices in scientific computing, 2017\nRead: Riquelme and Gjorgjieva, Towards readable code in neuroscience, 2021\nCode: Set up ChatGPT\nPlease confirm you can complete the items in Introduction to Python\nAdvanced: 100 numpy exercises\nAdvanced: Beautiful, Idiomatic Python\n\n\n\nIntegrate & Fire Neuron\n\nRead: Abbott, Brain Res Bull, 1999.\nRead: Chapter 1, pages 5-12 @ C. Koch, Biophysics of computation, 1998.\nLecture Slides\nCode: Integrate & Fire Neuron in Python\n\n\n\nHodgkin-Huxley Neuron\n\nRead: Chapter 2, pages 25-42 @ E. Izhikevich, Dynamical Systems in Neuroscience, 2007.\nRead: Hodgkin-Huxley 1-page cheat sheet\nAdvanced: Hodgkin and Huxley, J Physiol, 1952.\nLecture Slides\nCode: Hodgkin-Huxley Neuron in Python\n\n\n\nPerceptron\n\nRead: Electronic Brain Teaches Itself, New York Times, 13 July 1958\nRead: Perceptron Tested for Photo Analysis, Aviation Weekly, 1961\nRead: Undercover Algorithm, O’Connor, 2022\nLecture Slides\nCode: Training a Perceptron in Python\n\n\n\nBackpropagation\n\nRead: Lee or Delusions of Artificial Intelligence, 2023\nWatch: Inside an artificial brain\nLecture Slides\nCode: Backpropagation in a Simple Neural Network in Python\n\n\n\nRegression\n\nRead: Chapter 3 of An Introduction to Statistical Learning (Free via BU Library)\nLecture Slides\nCode: Regression Example in Python"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_3.html",
    "href": "Analyzing_Rhythms_Lab_3.html",
    "title": "Analyzing Rhythms Part 3 (Spectra of spike trains)",
    "section": "",
    "text": "# Load modules we'll need.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nExample: a randomly spiking neuron\nTo start, let’s create a fake spike train for a randomly spiking neuron, and compute the autocovariance and spectrum.\n\nN  = 5000;                          # Number of bins.                   \ndt = 0.001;                         # Duration of each bin [s].\nT  = N*dt;                          # Total time of observation [s].\ntm = np.arange(0,N)*dt;             # Time axis for plotting\n\nlambda0 = 5                         # Average firing rate [Hz]\np0      = lambda0*dt;               # Probability of a spike in a time bin\ndn      = np.random.binomial(1,p0,N)# Create the spike train as \"coin flips\"\n\nplt.plot(tm, dn)                    # Plot it.\nplt.xlabel('Time [s]');\n\n\n# Compute the autocovariance.\n\nac_xx = \"SOMETHING\n\n                                    # Plot it.\nlags  = np.arange(-N + 1, N)        # Create a lag axis,\nplt.plot(lags * dt, ac_xx)          # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\n\nprint('lambda0*dt = ',lambda0*dt)  # Compare expected r_{nn}[0] to computed value.\nprint('r_{nn}[0]  = ',ac_xx[N-1])\n\n\n# Compute the spectrum.\n\nDj = \"SOMETHING\"                            # Compute the FT,\nPj = \"SOMETHING\"                            # ... and the spectrum.\n\nf = np.fft.fftfreq(N, dt)                   # Create frequency axis.\n\nplt.plot(f, np.real(Pj))                    # Plot the spectrum.\nin_class_guess = \"SOMETHING\"                # And our guess from in-class analysis.\nplt.plot(f,in_class_guess*np.ones(N), 'b')\nplt.xlabel('Frequency [Hz]');\n\n\n# Repeat the entire simulation many times, and plot the average autocovariance and spectrum\n\nK  = 1000                                       # Number of times to repeat the simulation.\nlambda_est = np.zeros(K)                        # Vector to store estimate of lambda.\nP  = np.zeros([K,np.size(Pj)])                  # Matrix to store spectra,\nAC = np.zeros([K,2*N-1])                        # ... and AC.\n\nfor k in np.arange(K):                          # For each repeat,\n    dn = np.random.binomial(1,p0,N)             # ... create a new spike train.\n\n    lambda_est[k] = \"SOMETHING\"\n                                                # Compute the AC,\n    ac_xx = \"SOMETHING\"\n    AC[k,:] = ac_xx                             # ... and save the result.\n    \n    Dj = \"SOMETHING\"                            # Compute the FT,\n    Pj = \"SOMETHING\"                            # ... and the spectrum,\n    P[k,:] = Pj                                 # ... and save the result.\n\nplt.figure()                                    # Plot it.\nplt.plot(lags*dt, np.mean(AC,0))\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\n\nplt.figure()\nplt.plot(f, np.mean(P,0))                       # Plot the spectrum, averaged over repeats\nin_class_guess = \"SOMETHING\"                    # Use lambda_est to compute our guess from in-class analysis.\nplt.plot(f,in_class_guess*np.ones(N), 'b')\nplt.xlabel('Frequency [Hz]');\n\n\n\nExample: a randomly spiking neuron + refractory period\nNow, let’s create a fake spike train for a randomly spiking neuron with a refractory period, and compute the autocovariance and spectrum.\n\nN  = 5000;                          # Number of bins.                   \ndt = 0.001;                         # Duration of each bin [s].\nT  = N*dt;                          # Total time of observation [s].\ntm = np.arange(0,N)*dt;             # Time axis for plotting\n\nlambda0 = 5                         # Average firing rate [Hz]\np0      = lambda0*dt;               # Probability of a spike in a time bin\ndn      = np.random.binomial(1,p0,N)# Create the spike train as \"coin flips\"\nrefractory_period = 10              # Add a refractory period\nfor i in np.arange(N):\n    if dn[i]==1:\n        dn[i+1:i+refractory_period] = 0\n\nplt.plot(tm, dn)                    # Plot it.\nplt.xlabel('Time [s]');\n\n\n# Compute the autocovariance.\n\n\n# Compute the spectrum.\n\n\n# Repeat the entire simulation many times, and plot the average autocovariance and spectrum"
  },
  {
    "objectID": "Coherence_Lab_Part_1.html",
    "href": "Coherence_Lab_Part_1.html",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "",
    "text": "# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram"
  },
  {
    "objectID": "Coherence_Lab_Part_1.html#make-two-noise-signals",
    "href": "Coherence_Lab_Part_1.html#make-two-noise-signals",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "Make two noise signals",
    "text": "Make two noise signals\n\nN = 1000;\ndt= 0.001;\nT = N*dt;\nx = np.random.randn(N)\ny = np.random.randn(N)\nt = np.arange(0,N)*dt\n\nplt.plot(t,x)\nplt.plot(t,y)\nplt.xlabel('Time [s]');"
  },
  {
    "objectID": "Coherence_Lab_Part_1.html#compute-the-cross-covariance",
    "href": "Coherence_Lab_Part_1.html#compute-the-cross-covariance",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "Compute the cross-covariance",
    "text": "Compute the cross-covariance\n\ncc_xy = \"SOMETHING\"                          # Compute the covariance.\nlags = np.arange(-N + 1, N)                  # Create a lag axis,\nplt.plot(lags * dt, cc_xy)                   # ... and plot the result.\nplt.ylim([-0.1, 1])\nplt.xlabel('Lag [s]')\nplt.ylabel('Cross-covariance');"
  },
  {
    "objectID": "Coherence_Lab_Part_1.html#compute-the-coherence",
    "href": "Coherence_Lab_Part_1.html#compute-the-coherence",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "Compute the coherence",
    "text": "Compute the coherence\n\nXf = np.fft.fft(x - x.mean())           # Compute Fourier transform of x\nYf = np.fft.fft(y - y.mean())           # Compute Fourier transform of y\n\n# Compute the spectra\nSxx = \"SOMETHING\"  # Spectrum of x\nSyy = \"SOMETHING\"  # ... and y\nSxy = \"SOMETHING\"  # ... and the cross spectrum\n\n# Compute the coherence.\ncohr = \"SOMETHING\"\n\n# Define a frequency axis.\nf = np.fft.fftfreq(N, dt)\n\n# Plot the result.\nplt.plot(f, cohr.real)"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_2a.html",
    "href": "Analyzing_Rhythms_Lab_2a.html",
    "title": "Analyzing Rhythms Part 2a (Autocovariance)",
    "section": "",
    "text": "Load modules we’ll need.\n\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\n\nMake the noise signal.\n\nN = 1000;\ndt= 0.001;\nT = \"SOMETHING\"\nx = \"SOMETHING\"\nt = \"SOMETHING\"\n\nplt.plot(t,x)\nplt.xlabel('Time [s]');\n\n\n\nCompute the auto-covariance.\n\nac_xx = \"SOMETHING\"\nlags  = \"SOMETHING\"                  # Create a lag axis,\nplt.plot(lags, ac_xx)                # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\n\n\n\nCompute the spectrum.\n\nXf = np.fft.fft(x - x.mean())           # Compute Fourier transform of x\n\n# Compute the spectrum\nSxx = \"SOMETHING\"\n\n# Define a frequency axis.\nf = np.fft.fftfreq(N, dt)\n\n# Plot the result.\nplt.plot(f, Sxx)"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "",
    "text": "# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n# Load the data.\ndata = loadmat('AC_Example.mat')  # Load the data,\n# Data available here\n# https://github.com/Mark-Kramer/BU-MA665-MA666/tree/master/Data\n#\nd = data['d'][0]                # ... from the first electrode.\nt = data['t'][0]              # Load the time axis\nN = np.size(d,0)              # Store number of observations.\ndt = t[1]-t[0]                # Store sampling interval.\n\n####################################################################\nplt.plot(t,d);\nplt.xlabel('Time [s]');"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#load-the-data-and-look-at-it.",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#load-the-data-and-look-at-it.",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Load the data and look at it.",
    "text": "Load the data and look at it.\nQ. Do you see rhythms?\n\nConclusions\n\n\n\n\n\n# Code to compute the spectrum for the first trial.\nT = t[-1]\n\nXf = np.fft.fft(d - d.mean())           # Compute Fourier transform of x\n# Compute the spectrum\nSxx = 2 * dt ** 2 / T * (Xf * Xf.conj())  # Compute spectrum\n\n# Define a frequency axis.\nf = np.fft.fftfreq(N, dt)\n\ndf = 1/T;\nfNQ = 1/dt/2;\nfaxis = np.arange(0,fNQ,df)\n\n# Plot the result.\nplt.plot(f, Sxx, '*')\nplt.plot(faxis, Sxx[0:int(N/2)])\nplt.xlim([0, 15]);\n\n\n# Compute the spectrum\nT  = t[-1]\ndf = 1/T\nfNQ= 1/dt/2\n\nX   = np.fft.fft(d - np.mean(d))\nSxx = 2*dt**2/T * (X * np.conj(X))\nSxx = Sxx[0:int(N/2)].real;\n\nfaxis = np.arange(0, fNQ, df)\n\nplt.plot(faxis, 10*np.log10(Sxx))\nplt.xlim([0,20])\nplt.ylim([-100, 0]);"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#compute-the-spectrum.",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#compute-the-spectrum.",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Compute the spectrum.",
    "text": "Compute the spectrum.\nQ. What do you find? What rhythms are present in the data?\n\nConclusions\n\n\n\n\n\n# Code to compute the autocovariance\n\n# With function\nac_xx = 1 / N * np.correlate(d,d, 'full')    # Compute the covariance.\nlags  = np.arange(-N + 1, N)                  # Create a lag axis,\nplt.plot(lags, ac_xx);                        # ... and plot the result."
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#compute-the-autocovariance.",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#compute-the-autocovariance.",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Compute the autocovariance.",
    "text": "Compute the autocovariance.\nQ. What do you find? Is it consistent with the spectrum?\n\nConclusions"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#example-spectrum-ftautocovariance",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2b-SOLUTION.html#example-spectrum-ftautocovariance",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Example: Spectrum = FT{Autocovariance}",
    "text": "Example: Spectrum = FT{Autocovariance}\nMake a simple signal.\n\ndt = 0.001\nN  = 1000\nt  = np.arange(0,N)*dt\nd  = 1*np.sin(2*np.pi*10*t) + 1*np.random.randn(N)\n\nCompute the autocovariance with a modifications: circular-shift the data\n\nrxx = [];\nlags = np.arange(-int(N/2),int(N/2));\nfor idx,L in enumerate(lags):\n    rxx = np.append(rxx, 1/N*np.sum(np.roll(d,L) * d))\nplt.plot(lags, rxx)\nplt.xlabel('Lags [indices]');\nplt.ylabel('Autocovariance rxx');\n\n\n\n\n\n\n\n\nCompute the spectrum via FT and directly from the data.\n\n# Compute the spectrum from the FT{rxx}\nSxx_via_rxx = 2*dt*np.fft.fft(rxx)\n\n# Compute the spectrum from the data.\nT   = t[-1];\nxf  = np.fft.fft(d);\nSxx = 2 * dt ** 2 / T * (xf * xf.conj()) \n\nplt.plot(10*np.log10(Sxx))\nplt.plot(10*np.log10(Sxx_via_rxx), 'o')\nplt.xlabel('Freq **Index**')\nplt.legend({'Direct Sxx', 'Sxx via rxx'})\nplt.xlim([0,100]);"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_3_spikes-SOULTION.html",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_3_spikes-SOULTION.html",
    "title": "Spectra of spike trains",
    "section": "",
    "text": "# Load modules we'll need.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nExample: a randomly spiking neuron\nTo start, let’s create a fake spike train for a randomly spiking neuron, and compute the autocovariance and spectrum.\n\nN  = 5000;                          # Number of bins.                   \ndt = 0.001;                         # Duration of each bin [s].\nT  = N*dt;                          # Total time of observation [s].\ntm = np.arange(0,N)*dt;             # Time axis for plotting\n\nlambda0 = 5                         # Average firing rate [Hz]\np0      = lambda0*dt;               # Probability of a spike in a time bin\ndn      = np.random.binomial(1,p0,N)# Create the spike train as \"coin flips\"\n\nplt.plot(tm, dn)                    # Plot it.\nplt.xlabel('Time [s]');\n\n\n\n\n\n\n\n\n\n# Compute the autocovariance.\n\nac_xx = 1 / N * np.correlate(dn-dn.mean(),dn-dn.mean(), 'full')\nlags = np.arange(-N + 1, N)                # Create a lag axis,\nplt.plot(lags * dt, ac_xx)                 # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\n\nprint('lambda0*dt = ',lambda0*dt)\nprint('r_{nn}[0]  = ',ac_xx[N-1])\n\nlambda0*dt =  0.005\nr_{nn}[0]  =  0.005172959999999988\n\n\n\n\n\n\n\n\n\n\n# Compute the spectrum.\n\nDj = np.fft.fft(dn - dn.mean())            # Compute the FT,\nPj = 2 * dt**2 / T * (Dj * Dj.conj())      # ... and the spectrum.\n\nf = np.fft.fftfreq(N, dt)                         # Create frequency axis.\n\nplt.plot(f, np.real(Pj))                   # Plot the spectrum.\nplt.plot(f,2*dt**2*lambda0*np.ones(N), 'b')# And our guess from in-class analysis.\nplt.xlabel('Frequency [Hz]');\n\n\n\n\n\n\n\n\n\n# Repeat the entire simulation many times, and plot the average spectrum\n\nK = 1000\nlambda_est = np.zeros(K)\nP  = np.zeros([K,np.size(Pj)])\nAC = np.zeros([K,2*N-1])\nfor k in np.arange(K):                          # For each repeat,\n    dn = np.random.binomial(1,p0,N)             # ... create a new spike train.\n\n    lambda_est[k] = np.sum(dn)/T;\n                                                # Compute the AC,\n    ac_xx = 1 / N * np.correlate(dn-dn.mean(),dn-dn.mean(), 'full')\n    AC[k,:] = ac_xx                             # ... and save the result.\n    \n    Dj = np.fft.fft(dn - dn.mean())             # Compute the FT,\n    Pj = np.real(2*dt**2/T*(Dj*Dj.conj()))      # ... and the spectrum,\n    P[k,:] = Pj                                 # ... and save the result.\n\nplt.figure()\nplt.plot(lags, np.mean(AC,0))\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\n\nplt.figure()\nplt.plot(f, np.mean(P,0))                      # Plot the spectrum, averaged over repeats\nplt.plot(f,2*dt**2*np.mean(lambda_est)*np.ones(N), 'b')     # And our guess from in-class analysis.\nplt.xlabel('Frequency [Hz]');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample: a randomly spiking neuron + refractory period\nNow, let’s create a fake spike train for a randomly spiking neuron with a refractory period, and compute the autocovariance and spectrum.\n\nN  = 5000;                          # Number of bins.                   \ndt = 0.001;                         # Duration of each bin [s].\nT  = N*dt;                          # Total time of observation [s].\ntm = np.arange(0,N)*dt;             # Time axis for plotting\n\nlambda0 = 5                         # Average firing rate [Hz]\np0      = lambda0*dt;               # Probability of a spike in a time bin\ndn      = np.random.binomial(1,p0,N)# Create the spike train as \"coin flips\"\n\nrefractory_period = 10              # Add a refractory period\nfor i in np.arange(N):\n    if dn[i]==1:\n        dn[i+1:i+refractory_period] = 0\n\nplt.plot(tm, dn)                    # Plot it.\nplt.xlabel('Time [s]');\n\n\n\n\n\n\n\n\n\n# Compute the autocovariance.\n\nac_xx = 1 / N * np.correlate(dn-dn.mean(),dn-dn.mean(), 'full')\nlags = np.arange(-N + 1, N)                # Create a lag axis,\nplt.plot(lags * dt, ac_xx)                 # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\nplt.xlim([-0.5, 0.5])\n\n\n\n\n\n\n\n\n\n# Compute the spectrum.\n\nDj = np.fft.fft(dn - dn.mean())            # Compute the FT,\nPj = 2 * dt**2 / T * (Dj * Dj.conj())      # ... and the spectrum.\n\nf = np.fft.fftfreq(N, dt)                         # Create frequency axis.\n\nplt.plot(f, np.real(Pj))                   # Plot the spectrum.\nplt.plot(f,2*dt**2*lambda0*np.ones(N), 'b')# And our guess from in-class analysis.\nplt.xlabel('Frequency [Hz]');\n\n\n\n\n\n\n\n\n\n# Repeat the entire simulation many times, and plot the average spectrum\n\nK = 1000\nlambda_est = np.zeros(K)\nP  = np.zeros([K,np.size(Pj)])\nAC = np.zeros([K,2*N-1])\nfor k in np.arange(K):                          # For each repeat,\n    dn = np.random.binomial(1,p0,N)             # ... create a new spike train.\n\n    refractory_period = 10              # Add a refractory period\n    for i in np.arange(N):\n        if dn[i]==1:\n            dn[i+1:i+refractory_period] = 0\n\n    lambda_est[k] = np.sum(dn)/T;\n                                                # Compute the AC,\n    ac_xx = 1 / N * np.correlate(dn-dn.mean(),dn-dn.mean(), 'full')\n    AC[k,:] = ac_xx                             # ... and save the result.\n    \n    Dj = np.fft.fft(dn - dn.mean())             # Compute the FT,\n    Pj = np.real(2*dt**2/T*(Dj*Dj.conj()))      # ... and the spectrum,\n    P[k,:] = Pj                                 # ... and save the result.\n\nplt.figure()\nplt.plot(lags*dt, np.mean(AC,0))\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\nplt.xlim([-0.5, 0.5])\n\nplt.figure()\nplt.plot(f, np.mean(P,0))                      # Plot the spectrum, averaged over repeats\nplt.plot(f,2*dt**2*np.mean(lambda_est)*np.ones(N), 'b')     # And our guess from in-class analysis.\nplt.xlabel('Frequency [Hz]');"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html",
    "title": "Load the data and look at it.",
    "section": "",
    "text": "Load modules we’ll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\nLoad the data.\ndata = loadmat('EEG-1.mat')    # Load the EEG data\n# Data available here\n# https://github.com/Mark-Kramer/BU-MA665-MA666/tree/master/Data\n#\nEEG  = data['EEG'].reshape(-1) # Extract the EEG variable\nt    = data['t'][0]            # ... and the t variablea\nLook at it.\nplt.plot(t,EEG)\nplt.xlabel('Time [s]')\nplt.ylabel('EEG');"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#preliminaries",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#preliminaries",
    "title": "Load the data and look at it.",
    "section": "Preliminaries",
    "text": "Preliminaries\nQ: What is the sampling interval (dt)?\n\ndt = t[1]-t[0]\nprint(dt)\n\n0.001\n\n\nQ. What is the sampling frequency (f0)?\n\nf0 = 1/dt\nprint(f0)\n\n1000.0\n\n\nQ. What is the number of points in the data (N)?\n\nN = np.size(EEG)\nprint(N)\n\n2000\n\n\nQ. What is the total time of the observation (T)?\n\nT = t[-1]\nprint(T)\n\n2.0"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#compute-the-spectrum-by-hand",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#compute-the-spectrum-by-hand",
    "title": "Load the data and look at it.",
    "section": "Compute the spectrum “by hand”",
    "text": "Compute the spectrum “by hand”\n\n# Q. What is the Nyquist frequency and frequency resolution?\nfNQ = f0/2\ndf  = 1/T\n\n# Q. What is the frequency axis?\nfj  = np.arange(0,fNQ,df)\n\n# Then, compute the Fourier transform \"by hand\".\nx = EEG\nX = np.ndarray(np.size(fj), complex);\nfor j in range( np.size(fj) ):\n    X[j] = np.sum(x * np.exp(-2*np.pi*1j*fj[j]*t))\n\n# And the spectrum,\nSxx = 2*dt**2/T * X * np.conj(X)\n\n# Plot it,\nplt.plot(fj, Sxx.real)\nplt.xlim([0, 100])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]');\n\n&lt;&gt;:21: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:21: SyntaxWarning: invalid escape sequence '\\m'\n/var/folders/mt/qz9sczyj4ys72smgdmwl7dc00016ry/T/ipykernel_28582/3024073482.py:21: SyntaxWarning: invalid escape sequence '\\m'\n  plt.ylabel('Power [$\\mu V^2$/Hz]');"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#compute-the-power-spectrum-using-the-fft-function.",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#compute-the-power-spectrum-using-the-fft-function.",
    "title": "Load the data and look at it.",
    "section": "Compute the power spectrum using the FFT function.",
    "text": "Compute the power spectrum using the FFT function.\n\nx  = EEG\nxf = np.fft.fft(x)                        # Compute Fourier transform of x\nSxx = 2 * dt ** 2 / T * (xf * xf.conj())  # Compute spectrum\nSxx = Sxx[0:int(N / 2)].real              # Ignore negative frequencies\n\nDefine the frequency axis\n\ndf  = 1/T;                # Determine frequency resolution\nfNQ = f0/2;               # Determine Nyquist frequency\nfaxis = np.arange(0,fNQ,df)        # Construct frequency axis\n\nPlot the spectrum versus frequency\nQ. What do you see?\n\nplt.plot(faxis, Sxx)\nplt.xlim([0, 100])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]');\n\n&lt;&gt;:4: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:4: SyntaxWarning: invalid escape sequence '\\m'\n/var/folders/mt/qz9sczyj4ys72smgdmwl7dc00016ry/T/ipykernel_28582/921985069.py:4: SyntaxWarning: invalid escape sequence '\\m'\n  plt.ylabel('Power [$\\mu V^2$/Hz]');\n\n\n\n\n\n\n\n\n\nPlot the spectrum versus frequency on a decibel scale.\nQ. Now what do you see?\n\nplt.figure()\nplt.plot(faxis, 10*np.log10(Sxx))   # Plot the spectrum in decibels.\nplt.xlim([0, 100])                               # Select the frequency range.\nplt.ylim([-60, 0])                               # Select the decibel range.\nplt.xlabel('Frequency [Hz]')                     # Label the axes.\nplt.ylabel('Power [dB]');\n\n\n\n\n\n\n\n\nPlot the spectrum versus frequency on a logarithmic frequency axis.\nQ. And now what do you see?\n\nplt.figure()\nplt.plot(faxis, 10*np.log10(Sxx))   # Plot the spectrum in decibels.\nplt.xscale('log')\nplt.xlim([df, 100])                                  # Select frequency range\nplt.ylim([-60, 0])                                   # ... and the decibel range.\nplt.xlabel('Frequency [Hz]')                         # Label the axes.\nplt.ylabel('Power [dB]');"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#apply-hanning-taper",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#apply-hanning-taper",
    "title": "Load the data and look at it.",
    "section": "Apply Hanning taper",
    "text": "Apply Hanning taper\nApply the Hanning taper to the data.\n\nx_tapered  = np.hanning(N) * x              # Apply the Hanning taper to the data.\nplt.figure()\nplt.plot(t,x)\nplt.plot(t,x_tapered);\n\n\n\n\n\n\n\n\nApply the Hanning taper and look at the spectrum.\n\nxf_tapered  = np.fft.fft(x_tapered)              # Compute Fourier transform of x.\nSxx_tapered = 2 * dt ** 2 / T * (xf_tapered * xf_tapered.conj())           # Compute the spectrum,\nSxx_tapered = np.real(Sxx_tapered[:int(N / 2)])  # ... and ignore negative frequencies.\n\nplt.figure()\nplt.semilogx(faxis,10*np.log10(Sxx))         # Plot spectrum of untapered signal.  \nplt.semilogx(faxis,10*np.log10(Sxx_tapered)) # Plot spectrum vs tapered signal.\nplt.xlim([faxis[1], 100])                    # Select frequency range,\nplt.ylim([-70, 20])                          # ... and the power range.\nplt.xlabel('Frequency [Hz]')                 # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]')\n\n&lt;&gt;:11: SyntaxWarning: invalid escape sequence '\\m'\n&lt;&gt;:11: SyntaxWarning: invalid escape sequence '\\m'\n/var/folders/mt/qz9sczyj4ys72smgdmwl7dc00016ry/T/ipykernel_28582/3281865677.py:11: SyntaxWarning: invalid escape sequence '\\m'\n  plt.ylabel('Power [$\\mu V^2$/Hz]')\n\n\nText(0, 0.5, 'Power [$\\\\mu V^2$/Hz]')"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#spectrogram",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_1-SOLUTION.html#spectrogram",
    "title": "Load the data and look at it.",
    "section": "Spectrogram",
    "text": "Spectrogram\n\n# Plot the spectrogram.\n\nFs = 1 / dt               # Define the sampling frequency,\ninterval = int(Fs)        # ... the interval size,\noverlap = int(Fs * 0.95)  # ... and the overlap intervals\n\n                          # Compute the spectrogram\nf0, t0, Sxx0 = spectrogram(\n    EEG,                  # Provide the signal,\n    fs=Fs,                # ... the sampling frequency,\n    nperseg=interval,     # ... the length of a segment,\n    noverlap=overlap)     # ... the number of samples to overlap,\nplt.pcolormesh(t0, f0, 10 * np.log10(Sxx0),\n               cmap='jet')# Plot the result\nplt.colorbar()            # ... with a color bar,\nplt.ylim([0, 70])             # ... set the frequency range,\nplt.xlabel('Time [s]')       # ... and label the axes\nplt.ylabel('Frequency [Hz]');"
  },
  {
    "objectID": "Dont-Sync-2024/7. Introduction to Rhythms/Untitled.html",
    "href": "Dont-Sync-2024/7. Introduction to Rhythms/Untitled.html",
    "title": "BU MA665+MA666",
    "section": "",
    "text": "# Load modules\nimport scipy.io as sio\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\nt = np.arange(0, 2, 0.001)\n\n\nf = 10\nx = np.sin(2*np.pi*f*t)\ny = np.cos(2*np.pi*f*t)\n\n\nplt.plot(t,x)\nplt.plot(t,y)\n\n\n\n\n\n\n\n\n\nf1 = 10;\nx1 = np.cos(2*np.pi*t*f1);\n\nf2 = 1;\nx2 = np.sin(2*np.pi*t*f2);\n\nplt.plot(t,x1)\nplt.plot(t,x2)\nplt.title(np.sum(x1*x2))\n\nText(0.5, 1.0, '-8.260059303211165e-14')\n\n\n\n\n\n\n\n\n\n\ndf = pd.read_csv(\"https://raw.githubusercontent.com/Mark-Kramer/BU-MA665-MA666/master/Data/Rhythms_1.csv\")\n\n# Extract the variables from the loaded data\ndata = np.array(df.iloc[:,0])  #Get the values associated with the first column of the dataframe\nt    = np.array(df.iloc[:,1])  #Get the values associated with the second column of the dataframe\n\n\nf1 = 8\nx  = np.cos(2*np.pi*f1*t)\n\nplt.plot(t, data)\nplt.plot(t, x)\n\nplt.title( np.sum(data*x) )\n\nText(0.5, 1.0, '50.10000000000001')"
  },
  {
    "objectID": "Dont-Sync-2024/11. Gamma Models/Gamma_Lab-SOLUTION.html",
    "href": "Dont-Sync-2024/11. Gamma Models/Gamma_Lab-SOLUTION.html",
    "title": "Gamma rhythms models",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np"
  },
  {
    "objectID": "Dont-Sync-2024/11. Gamma Models/Gamma_Lab-SOLUTION.html#begin-with-the-inhibitory-synapse-turned-off.",
    "href": "Dont-Sync-2024/11. Gamma Models/Gamma_Lab-SOLUTION.html#begin-with-the-inhibitory-synapse-turned-off.",
    "title": "Gamma rhythms models",
    "section": "Begin with the inhibitory synapse turned off.",
    "text": "Begin with the inhibitory synapse turned off.\n\nI0   = 30;    #Set the input drive to excite the cell.\ngI   = 0;     #Turn off inhibitory synapse, to start.\ntauI = 10;    #Set decay time of inhibitory synapse to 10ms.\nT0   = 100;   #Simulate for 100 ms.\n\n[V,s,t] = ing(I0,gI,tauI,T0)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');"
  },
  {
    "objectID": "Dont-Sync-2024/11. Gamma Models/Gamma_Lab-SOLUTION.html#turn-on-the-inhibitory-synapse.",
    "href": "Dont-Sync-2024/11. Gamma Models/Gamma_Lab-SOLUTION.html#turn-on-the-inhibitory-synapse.",
    "title": "Gamma rhythms models",
    "section": "Turn on the inhibitory synapse.",
    "text": "Turn on the inhibitory synapse.\n\ngI = 20;\n[V,s,t] = ing(I0,gI,tauI,T0);\nplt.subplot(2,1,1)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');\nplt.subplot(2,1,2)\nplt.plot(t,s,'r'); plt.xlabel('Time [ms]'); plt.ylabel('Inhibitory synaptic gate');\n\n\n\n\n\n\n\n\nQ: How does the spiking frequency change?\nQ: How do the synapses evolve?\nQ: This model captures 3 experimental observations we discussed in class. To generate gamma, 1) The cell needs sufficient excitatory drive, 2) The GABA synapse is critical, and 3) Altering the decay time of the inhibitory synapse changes the gamma frequency.\nShow that all three observations are captured by this model.\n\n#1. \nplt.subplot(2,1,1)\nI0=30; gI=20; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='I0=30');\nI0=0;  gI=20; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='I0=0'); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]'); plt.legend()\n\nplt.subplot(2,1,2)\nI0=30; gI=20; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,s, label='I0=30');\nI0=0;  gI=20; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,s, label='I0=0'); plt.xlabel('Time [ms]'); plt.ylabel('Inhibitory synaptic gate'); plt.legend();\n\n\n\n\n\n\n\n\n\n#2. \nplt.subplot(2,1,1)\nI0=30; gI=20; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='gI=20');\nI0=30; gI=0; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='gI=0'); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]'); plt.legend()\n\nplt.subplot(2,1,2)\nI0=30; gI=20; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='gI=20');\nI0=30; gI=0; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='gI=0'); plt.xlabel('Time [ms]'); plt.ylabel('Inhibitory synaptic gate'); plt.legend();\n\n\n\n\n\n\n\n\n\n#3.\nplt.subplot(2,1,1)\nI0=30; gI=20;  tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='tauI=10'); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');\nI0=30;  gI=20; tauI=20; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='tauI=20'); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]'); plt.legend();\n\nplt.subplot(2,1,2)\nI0=30; gI=20; tauI=10; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='tauI=10');\nI0=30;  gI=20; tauI=20; [V,s,t] = ing(I0,gI,tauI,T0);\nplt.plot(t,V, label='tauI=20'); plt.xlabel('Time [ms]'); plt.ylabel('Inhibitory synaptic gate'); plt.legend();"
  },
  {
    "objectID": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html",
    "href": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html",
    "title": "Analyze an example data set",
    "section": "",
    "text": "# Load modules we'll need.\n\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram"
  },
  {
    "objectID": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#step-1-load-the-data-and-look-at-it.",
    "href": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#step-1-load-the-data-and-look-at-it.",
    "title": "Analyze an example data set",
    "section": "Step 1: Load the data and look at it.",
    "text": "Step 1: Load the data and look at it.\nQ. Do you observe evidence of cross-frequency coupling?\n\nConclusions\n\n\n\n\n\n# Load the data.\n\ndata = loadmat('LFP-1.mat')          # Load the data,\nt = data['t'][0]                     # ... extract t, the time variable,\nLFP = data['LFP'][0]                 # ... and LFP, the voltage variable.\ndt = t[1] - t[0]                     # Define the sampling interval,\nfNQ = 1 / dt / 2                     # ... and Nyquist frequency. \n\n\nplt.plot(t,LFP)\nplt.xlim([90, 91])"
  },
  {
    "objectID": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#spectral-analysis",
    "href": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#spectral-analysis",
    "title": "Analyze an example data set",
    "section": "Spectral analysis",
    "text": "Spectral analysis\nQ. What rhythms are present in the data?\n\nConclusions\n\n\n\n\n\ndt = t[2]-t[1]\nf0 = 1/dt\nN = np.size(LFP)\nT = N*dt\n\nx  = LFP\nxf = np.fft.fft(x)                        # Compute Fourier transform of x\nSxx = 2 * dt ** 2 / T * (xf * xf.conj())  # Compute spectrum\nSxx = Sxx[0:int(N / 2)].real              # Ignore negative frequencies\n\n# Define the frequency axis\ndf = 1/T                     # Determine frequency resolution\nfNQ = f0 / 2                 # Determine Nyquist frequency\nfaxis = np.arange(0,fNQ,df)  # Construct frequency axis\n\n# Plot the spectrum versus frequency.\nplt.plot(faxis, 10*np.log10(Sxx))\n#plt.xlim([20, 200])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]');"
  },
  {
    "objectID": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#phase-amplitude-coupling-step-1",
    "href": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#phase-amplitude-coupling-step-1",
    "title": "Analyze an example data set",
    "section": "Phase-amplitude coupling (Step 1)",
    "text": "Phase-amplitude coupling (Step 1)\nQ. Filter the data into low and high frequency bands. What frequency bands will you choose?\nQ. Visualize the data; does the filtering make sense?\n\nConclusions\n\n\n\n\n\nfrom scipy import signal\n\n# Low frequency band.\nWn = [4,8];                       # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVlo = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data.\n\n# High frequency band.\nWn = [80, 140];                      # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVhi = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data.\n\nplt.plot(t,LFP)\nplt.plot(t,Vlo)\nplt.plot(t,Vhi)\nplt.xlim([10,11])\n\n/var/folders/4q/0gs6wrln525b1bf55lw2p0180000gn/T/ipykernel_43455/4036158071.py:7: DeprecationWarning: Keyword argument 'nyq' is deprecated in favour of 'fs' and will be removed in SciPy 1.12.0.\n  b = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\n/var/folders/4q/0gs6wrln525b1bf55lw2p0180000gn/T/ipykernel_43455/4036158071.py:14: DeprecationWarning: Keyword argument 'nyq' is deprecated in favour of 'fs' and will be removed in SciPy 1.12.0.\n  b = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');"
  },
  {
    "objectID": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#phase-amplitude-coupling-step-2",
    "href": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#phase-amplitude-coupling-step-2",
    "title": "Analyze an example data set",
    "section": "Phase-amplitude coupling (Step 2)",
    "text": "Phase-amplitude coupling (Step 2)\nQ. How do you extract the amplitude and phase from the filtered signals?\nQ. For Vhi and Vlo, we need to compute the analytic signal, and then the phase or amplitude. What Python functions do you need?\nQ. Visualize the amplitude and phase; does it make sense?\n\nConclusions\n\n\n\n\n\nphi = np.angle(signal.hilbert(Vlo))\namp = np.abs(signal.hilbert(Vhi))\n\nplt.plot(t,Vlo)\nplt.plot(t,phi)\nplt.xlim([10,11])\n\n\n\n\n\n\n\n\n\nplt.plot(t,Vhi)\nplt.plot(t,amp)\nplt.xlim([10,11])"
  },
  {
    "objectID": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#phase-amplitude-coupling-step-3",
    "href": "Dont-Sync-2024/10. CFC/CFC_Lab-SOLUTION.html#phase-amplitude-coupling-step-3",
    "title": "Analyze an example data set",
    "section": "Phase-amplitude coupling (Step 3)",
    "text": "Phase-amplitude coupling (Step 3)\nQ. Determine if the phase and amplitude are related by making a phase-amplitude histogram. What is the value of the statistic h?\nQ. Does this result suggest CFC occurs in these data?\nQ. If no CFC occurred in the data, what would you expect to find in the plot of average amplitude versus phase?\n\nConclusions\n\n\n\n\n\np_bins = np.arange(-np.pi, np.pi, 0.1)\n#print(p_bins)\na_mean = np.zeros(np.size(p_bins)-1)\np_mean = np.zeros(np.size(p_bins)-1)\nfor k in range(np.size(p_bins)-1):\n    pL = p_bins[k]\n    pR = p_bins[k+1]\n    indices = (phi&gt;=pL) & (phi&lt;pR)\n    a_mean[k] = np.mean(amp[indices])\n    p_mean[k] = np.mean([pL, pR])\nplt.plot(p_mean, a_mean)\nplt.xlabel('Low frequency phase')\nplt.ylabel('High frequency amp')\n\nh = np.max(a_mean) - np.min(a_mean)\nprint(h)\n\n0.16717202495763905"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Spike-Field-Coherence-Lab-SOLUTION_NOT_NEEDED.html",
    "href": "Dont-Sync-2024/9. Coherence/Spike-Field-Coherence-Lab-SOLUTION_NOT_NEEDED.html",
    "title": "Dependence on rate (Part 1)",
    "section": "",
    "text": "Dependence on rate (Part 1)\n\nimport scipy.io as io\nimport scipy.signal as signal\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Load the data and plot it.\ndata = io.loadmat('spikes-LFP-1.mat')       # Load the multiscale data,\ny = data['y']                                # ... get the LFP data,\nn = data['n']                                # ... get the spike data,\nt = data['t'].reshape(-1)                    # ... get the time axis,\nK = np.shape(n)[0]                           # Get the number of trials,\nN = np.shape(n)[1]                           # ... and the number of data points in each trial,\ndt = t[1]-t[0]                               # Get the sampling interval.\n\n\nplt.stem(t,2*n[0,:], 'k')\nplt.xlim([0, 0.25])\nplt.ylim([0, 2.1])\n\n\n\n\n\n\n\n\n\nFor convenience, make a function to compute the cohernece.\n\ndef coherence(n,y,t):                           #INPUT (spikes, fields, time)\n    K = np.shape(n)[0]                          #... where spikes and fields are arrays [trials, time]\n    N = np.shape(n)[1]\n    T = t[-1]\n    SYY = np.zeros(int(N/2+1))\n    SNN = np.zeros(int(N/2+1))\n    SYN = np.zeros(int(N/2+1), dtype=complex)\n    \n    for k in np.arange(K):\n        yf = np.fft.rfft((y[k,:]-np.mean(y[k,:])) *np.hanning(N))    # Hanning taper the field,\n        nf = np.fft.rfft((n[k,:]-np.mean(n[k,:])))                   # ... but do not taper the spikes.\n        SYY = SYY + ( np.real( yf*np.conj(yf) ) )/K                  # Field spectrum\n        SNN = SNN + ( np.real( nf*np.conj(nf) ) )/K                  # Spike spectrum\n        SYN = SYN + (          yf*np.conj(nf)   )/K                  # Cross spectrum\n\n    cohr = np.abs(SYN) / np.sqrt(SYY) / np.sqrt(SNN)                 # Coherence\n    f = np.fft.rfftfreq(N, dt)                                       # Frequency axis for plotting\n    \n    return (cohr, f, SYY, SNN, SYN)\n\nLet’s try it:\n\n[cohr, f, SYY, SNN, SYN] = coherence(n,y,t)\nplt.plot(f,cohr)\nplt.xlim([0, 100]); plt.xlabel('Frequency [Hz]'); plt.ylabel('Coherence');\n\n\n\n\n\n\n\n\n\n\nMake a function to thin a spike train.\n\ndef thinned_spike_train(n, thinning_factor):              # Thin the spike train (n) by the thinning_factor.\n    n_thinned = np.copy(n)                                # Make a copy of the spike train data.\n    for k in np.arange(K):                                # For each trial,\n        spike_times = np.where(n[k,:]==1)                 # ...find the spikes.\n        n_spikes = np.size(spike_times)                   # ...determine number of spikes.\n        spike_times_random = spike_times[0][np.random.permutation(n_spikes)]    # ...permute spikes indices,\n        n_remove=int(np.floor(thinning_factor*n_spikes))  # ... determine number of spikes to remove,\n        n_thinned[k,spike_times_random[1:n_remove]]=0     # remove the spikes.\n    return n_thinned\n\nLet’s try it:\n\nplt.clf()\nplt.plot(t, n[0,:], 'k')\nplt.plot(t, thinned_spike_train(n,0.5)[0,:], 'r');\nplt.xlim([0.2, 0.3])\nplt.legend(['Original', 'Thinned']);\n\n\n\n\n\n\n\n\n\n\nCompare the spike-field coherence for original and thinned data.\n\n[cohr, f, SYY, SNN, SYN] = coherence(n,y,t)                          # Coherence for original spike train.\nplt.clf()\nplt.plot(f,cohr, 'b')\n[cohr, f, SYY, SNN, SYN] = coherence(thinned_spike_train(n,0.5),y,t) # ... and for the thinned spike train.\nplt.plot(f,cohr, 'r')\nplt.xlim([40, 50])\nplt.legend(['Original', 'Thinned'])\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\n\n\n\n\n\n\n\n\n\n\nRepeat for different thinning factors.\n\nplt.figure(1); plt.clf(); plt.figure(2); plt.clf()\ncounter=1\nfor thin_factor in np.arange(0,1,0.25):\n    thinned = thinned_spike_train(n,thin_factor)\n    [cohr, f, SYY, SNN, SYN] = coherence(thinned,y,t) # ... and for the thinned spike train.\n    plt.figure(1)\n    plt.plot(f,cohr,label=str(thin_factor))\n    \nplt.figure(1)\nplt.xlim([40, 50])\nplt.legend()\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\n\n&lt;Figure size 640x480 with 0 Axes&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\nDependence on rate (Part 2)\n\nSimulate two simple spiking neurons, with activity dependent on a field.\n\ndef sim_two_neurons(baseline_rate_A, baseline_rate_B, field_coupling_A, field_coupling_B):\n    K = 100                            # Number of trials.\n    N = 1000                           # Points per trial.\n    A = np.zeros([K,N])                # Array to hold spikes A.\n    B = np.zeros([K,N])                # Array to hold spikes B.\n    y = np.zeros([K,N])                # Array to hold field.\n    for k in np.arange(K):             # For each trial,\n        y[k,:] = np.sin(2*np.pi*t*10) + 0.1*np.random.randn(N)    # ... generate a field,\n        A[k,:] = np.random.binomial(1,0.001*np.exp(baseline_rate_A+field_coupling_A*y[k,:]))      # ... generate spikes #A that depend on the field,\n        B[k,:] = np.random.binomial(1,0.001*np.exp(baseline_rate_B+field_coupling_B*y[k,:]))      # ... generate spikes #B that depend on the field.\n    return A,B,y\n\n\n\nVisualize example trials.\n\nplt.clf()\nrate_A = 1.0;  coupling_A = 1             # Fix the rates and coupling to field for each neuron.\nrate_B = 0.5;  coupling_B = 1           # Simulate the two neurons.\nA,B,y = sim_two_neurons(rate_A, rate_B, coupling_A, coupling_B)\nn_trial = 0;                                # Select a trial to plot.\nplt.plot(t,A[n_trial,:])\nplt.plot(t,B[n_trial,:])\nplt.plot(t,y[n_trial,:])\nplt.legend([\"Neuron A\", \"Neuron B\", \"Field\"]);\n\n\n\n\n\n\n\n\n\n\nCompute the average rate of each neuron\n\nrateA = np.mean(sum(A,1)/t[-1])\nrateB = np.mean(sum(B,1)/t[-1])\n\nprint(\"A(Rate) = \", rateA, \", B(Rate) = \", rateB)\n\nA(Rate) =  1.375 , B(Rate) =  1.213\n\n\n\n\nCompute the spike-field coherence.\n\nplt.clf()\n\n[cohr, f, SYY, SNN, SYN] = coherence(A,y,t); plt.plot(f,cohr)\n\n[cohr, f, SYY, SNN, SYN] = coherence(B,y,t); plt.plot(f,cohr)\n\nplt.xlim([0,20])\nplt.ylim([0,1])\nplt.legend(['Neuron A', 'Neuron B'])\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\n\n\n\n\n\n\n\n\n\n\nRepeat coherence calculation for many realizations\n\nbaseline_A = 2.0;  coupling_A = 0.5   # Fix the rates and coupling to field for each neuron.\nbaseline_B = 1.0;  coupling_B = 0.5\ncohr_A = np.zeros([501,100])\ncohr_B = np.zeros([501,100])\nfor k in np.arange(100):              # For 100 realizations, simulate the neurons & compute coherence.\n    A,B,y = sim_two_neurons(baseline_A, baseline_B, coupling_A, coupling_B)\n    [cohr, f, SYY, SNN, SYN] = coherence(A,y,t); cohr_A[:,k] = cohr\n    [cohr, f, SYY, SNN, SYN] = coherence(B,y,t); cohr_B[:,k] = cohr\n\n\n# Plot the coherence results.\nplt.clf()\nmn = np.mean(cohr_A,1); se = np.std( cohr_A,1)/np.sqrt(np.shape(cohr_A)[1])\nplt.plot(f,mn,'b',label=\"Neuron A\"); plt.plot(f,mn-2*se, 'b:'); plt.plot(f,mn+2*se, 'b:');\nmn = np.mean(cohr_B,1); se = np.std( cohr_B,1)/np.sqrt(np.shape(cohr_B)[1])\nplt.plot(f,mn,'r',label=\"Neuron B\"); plt.plot(f,mn-2*se, 'r:'); plt.plot(f,mn+2*se, 'r:');\nplt.xlim([5,15]); plt.ylim([0,1]);\nplt.legend()\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\nplt.title('Neuron A Rate: Baseline=' + str(baseline_A) + ', Coupling=' + str(coupling_A) + '\\n'\n          'Neuron B Rate: Baseline=' + str(baseline_B) + ', Coupling=' + str(coupling_B));"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "",
    "text": "# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html#make-two-noise-signals",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html#make-two-noise-signals",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "Make two noise signals",
    "text": "Make two noise signals\n\nN = 1000;\ndt= 0.001;\nT = N*dt;\nx = np.random.randn(N)\ny = np.random.randn(N)\nt = np.arange(0,N)*dt\n\nplt.plot(t,x)\nplt.plot(t,y)\nplt.xlabel('Time [s]');"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html#compute-the-cross-covariance",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html#compute-the-cross-covariance",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "Compute the cross-covariance",
    "text": "Compute the cross-covariance\n\ncc_xy = 1/N*np.correlate(x,y, 'full')\nlags = np.arange(-N + 1, N)                  # Create a lag axis,\nplt.plot(lags * dt, cc_xy)                   # ... and plot the result.\nplt.ylim([-0.1, 1])\nplt.xlabel('Lag [s]')\nplt.ylabel('Cross-covariance');"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html#compute-the-coherence",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_1-SOLUTION.html#compute-the-coherence",
    "title": "Coherence Part 1 (Two noise signals)",
    "section": "Compute the coherence",
    "text": "Compute the coherence\n\nXf = np.fft.fft(x - x.mean())           # Compute Fourier transform of x\nYf = np.fft.fft(y - y.mean())           # Compute Fourier transform of y\n\n# Compute the spectra\nSxx = 2*dt**2/T * (Xf * np.conj(Xf))  # Spectrum of E1 trials\nSyy = 2*dt**2/T * (Yf * np.conj(Yf))  # ... and E2 trials\nSxy = 2*dt**2/T * (Xf * np.conj(Yf))  # ... and the cross spectrum\n\n# Compute the coherence.\ncohr = np.abs(Sxy) / (np.sqrt(Sxx) * np.sqrt(Syy))\n\n# Define a frequency axis.\nf = np.fft.fftfreq(N, dt)\n\n# Plot the result.\nplt.plot(f, cohr.real)"
  },
  {
    "objectID": "Dont-Sync-2024/Untitled.html",
    "href": "Dont-Sync-2024/Untitled.html",
    "title": "BU MA665+MA666",
    "section": "",
    "text": "# Load necessary packages\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef damped_harmonic_oscillator(omega,beta,noise,T0):\n\n    dt = 0.01;\n    T  = int(np.ceil(T0/dt))\n\n    t = np.arange(0,T)*dt\n    F = np.zeros([T,1])         # Set up forcing,\n    F[int(0.25*T)] = 1;         # ... give it a kick 25% of way into simulation.\n    x = np.zeros([T,1])\n    y = np.zeros([T,1])\n\n    x[0]=0\n    y[0]=0\n    \n    for i in range(0,T-1):\n        x[i+1] = x[i] + dt*(y[i]);\n        y[i+1] = y[i] + dt*(-omega**2*x[i] - 2*beta*y[i] + F[i] + noise*np.random.randn());\n\n    return x,t\n\n\nf     = 2;\nomega = 2*np.pi*f;\nbeta  = 1;\nnoise = 1;\nT0    = 10\nx,t   = damped_harmonic_oscillator(omega,beta,noise,T0);\nplt.plot(t,x);"
  },
  {
    "objectID": "Coherence_Lab_Part_3.html",
    "href": "Coherence_Lab_Part_3.html",
    "title": "Coherence Part 3 (spike-field coherence)",
    "section": "",
    "text": "Dependence on rate (Part 1)\n\nimport scipy.io as io\nimport scipy.signal as signal\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Load the data and plot it.\ndata = io.loadmat('Data/spikes-LFP-1.mat')   # Load the multiscale data,\ny = data['y']                                # ... get the LFP data,\nn = data['n']                                # ... get the spike data,\nt = data['t'].reshape(-1)                    # ... get the time axis,\nK = np.shape(n)[0]                           # Get the number of trials,\nN = np.shape(n)[1]                           # ... and the number of data points in each trial,\ndt = t[1]-t[0]                               # Get the sampling interval.\n\nplt.stem(t,n[0,:]);\nplt.xlabel('Time [s]');\n\n\nFor convenience, make a function to compute the cohernece.\n\ndef coherence(n,y,t):                           #INPUT (spikes, fields, time)\n    K = np.shape(n)[0]                          #... where spikes and fields are arrays [trials, time]\n    N = np.shape(n)[1]\n    T = t[-1]\n    SYY = np.zeros(int(N/2+1))\n    SNN = np.zeros(int(N/2+1))\n    SYN = np.zeros(int(N/2+1), dtype=complex)\n    \n    for k in np.arange(K):\n        yf = np.fft.rfft((y[k,:]-np.mean(y[k,:])))                   # FT of fields\n        nf = np.fft.rfft((n[k,:]-np.mean(n[k,:])))                   # FT of spikes\n        SYY = SYY + ( np.real( yf*np.conj(yf) ) )/K                  # Field spectrum\n        SNN = SNN + ( np.real( nf*np.conj(nf) ) )/K                  # Spike spectrum\n        SYN = SYN + (          yf*np.conj(nf)   )/K                  # Cross spectrum\n\n    cohr = np.abs(SYN) / np.sqrt(SYY) / np.sqrt(SNN)                 # Coherence\n    f = np.fft.rfftfreq(N, dt)                                       # Frequency axis for plotting\n    \n    return (cohr, f, SYY, SNN, SYN)\n\nLet’s try it:\n\n[cohr, f, SYY, SNN, SYN] = coherence(n,y,t)\nplt.plot(f,cohr)\nplt.xlim([0, 100]); plt.xlabel('Frequency [Hz]'); plt.ylabel('Coherence');\n\n\n\nMake a function to thin a spike train.\n\ndef thinned_spike_train(n, thinning_factor):              # Thin the spike train (n) by the thinning_factor.\n    n_thinned = np.copy(n)                                # Make a copy of the spike train data.\n    for k in np.arange(K):                                # For each trial,\n        spike_times = np.where(n[k,:]==1)                 # ...find the spikes.\n        n_spikes = np.size(spike_times)                   # ...determine number of spikes.\n        spike_times_random = spike_times[0][np.random.permutation(n_spikes)]    # ...permute spikes indices,\n        n_remove=int(np.floor(thinning_factor*n_spikes))  # ... determine number of spikes to remove,\n        n_thinned[k,spike_times_random[1:n_remove]]=0     # remove the spikes.\n    return n_thinned\n\nLet’s try it:\n\nplt.clf()\nplt.stem(t, n[0,:], 'k')\nplt.stem(t, thinned_spike_train(n,0.5)[0,:], 'r');\nplt.xlim([0.2, 0.3])\nplt.legend(['Original', 'Thinned']);\n\n\n\nCompare the spike-field coherence for original and thinned data.\n\n[cohr, f, SYY, SNN, SYN] = \"SOMETHING\"  # Coherence for original spike train.\nplt.clf()\nplt.plot(f,cohr, 'b')\n[cohr, f, SYY, SNN, SYN] = \"SOMETHING\"  # ... and for the thinned spike train.\nplt.plot(f,cohr, 'r')\nplt.xlim([40, 50])\nplt.legend(['Original', 'Thinned'])\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\n\n\n\nRepeat for different thinning factors.\n\nplt.figure();\nfor thin_factor in \"SOMETHING\n    thinned = \"SOMETHING\"                  # Make the thinned spike train\n    [cohr, f, SYY, SNN, SYN] =\"SOMETHING\"  # ... and compute the coherence\n    plt.plot(f,cohr,label=str(thin_factor))    # \n\nplt.xlim([40, 50])\nplt.legend()\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\n\n\n\n\n\nDependence on rate (Part 2)\n\nSimulate two simple spiking neurons, with activity dependent on a field.\n\ndef sim_two_neurons(baseline_rate_A, baseline_rate_B, field_coupling_A, field_coupling_B):\n    K = 100                            # Number of trials.\n    N = 1000                           # Points per trial.\n    A = np.zeros([K,N])                # Array to hold spikes A.\n    B = np.zeros([K,N])                # Array to hold spikes B.\n    y = np.zeros([K,N])                # Array to hold field.\n    for k in np.arange(K):             # For each trial,\n        y[k,:] = np.sin(2*np.pi*t*10) + 0.1*np.random.randn(N)    # ... generate a field,\n        A[k,:] = np.random.binomial(1,0.001*np.exp(baseline_rate_A+field_coupling_A*y[k,:]))      # ... generate spikes #A that may depend on the field,\n        B[k,:] = np.random.binomial(1,0.001*np.exp(baseline_rate_B+field_coupling_B*y[k,:]))      # ... generate spikes #B that may depend on the field.\n    return A,B,y\n\n\n\nVisualize example trials.\n\nplt.clf()\nrate_A = 1.0;  coupling_A = 1             # Fix the rates and coupling to field for each neuron.\nrate_B = 0.5;  coupling_B = 1             # Simulate the two neurons.\nA,B,y = sim_two_neurons(rate_A, rate_B, coupling_A, coupling_B)\nn_trial = 0;                              # Select a trial to plot.\nplt.plot(t,A[n_trial,:])\nplt.plot(t,B[n_trial,:])\nplt.plot(t,y[n_trial,:])\nplt.legend([\"Neuron A\", \"Neuron B\", \"Field\"]);\n\n\n\nCompute the average rate of each neuron\n\nrateA = np.mean(sum(A,1)/t[-1])\nrateB = np.mean(sum(B,1)/t[-1])\n\nprint(\"A(Rate) = \", rateA, \", B(Rate) = \", rateB)\n\n\n\nCompute the spike-field coherence.\n\nplt.clf()\n\n[cohr, f, SYY, SNN, SYN] = coherence(A,y,t); plt.plot(f,cohr)\n\n[cohr, f, SYY, SNN, SYN] = coherence(B,y,t); plt.plot(f,cohr)\n\nplt.xlim([0,20])\nplt.ylim([0,1])\nplt.legend(['Neuron A', 'Neuron B'])\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\n\n\n\nRepeat coherence calculation for many realizations\n\nbaseline_A = 2.0;  coupling_A = 0.5   # Fix the rates and coupling to field for each neuron.\nbaseline_B = 1.0;  coupling_B = 0.5\ncohr_A = np.zeros([501,100])\ncohr_B = np.zeros([501,100])\nfor k in np.arange(100):              # For 100 realizations, simulate the neurons & compute coherence.\n    A,B,y = sim_two_neurons(baseline_A, baseline_B, coupling_A, coupling_B)\n    [cohr, f, SYY, SNN, SYN] = coherence(A,y,t); cohr_A[:,k] = cohr\n    [cohr, f, SYY, SNN, SYN] = coherence(B,y,t); cohr_B[:,k] = cohr\n\n\n# Plot the coherence results.\nplt.clf()\nmn = np.mean(cohr_A,1); se = np.std( cohr_A,1)/np.sqrt(np.shape(cohr_A)[1])\nplt.plot(f,mn,'b',label=\"Neuron A\"); plt.plot(f,mn-2*se, 'b:'); plt.plot(f,mn+2*se, 'b:');\nmn = np.mean(cohr_B,1); se = np.std( cohr_B,1)/np.sqrt(np.shape(cohr_B)[1])\nplt.plot(f,mn,'r',label=\"Neuron B\"); plt.plot(f,mn-2*se, 'r:'); plt.plot(f,mn+2*se, 'r:');\nplt.xlim([5,15]); plt.ylim([0,1]);\nplt.legend()\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\nplt.title('Neuron A Rate: Baseline=' + str(baseline_A) + ', Coupling=' + str(coupling_A) + '\\n'\n          'Neuron B Rate: Baseline=' + str(baseline_B) + ', Coupling=' + str(coupling_B));"
  },
  {
    "objectID": "Bursting_Lab.html",
    "href": "Bursting_Lab.html",
    "title": "Bursting Neuron",
    "section": "",
    "text": "The goal in this notebook is to update the HH equations to include a new (slow) current and produce bursting activity.\nTo do so, start with the HH code available here.\nUpdate the HH model to include the \\(\\bf{g_K-}\\)“M” current listed in Table A2 of this publication.\nIn the code below, we’ll use the variable B to define the gate for this current."
  },
  {
    "objectID": "Bursting_Lab.html#challenges",
    "href": "Bursting_Lab.html#challenges",
    "title": "Bursting Neuron",
    "section": "Challenges",
    "text": "Challenges\n\n1. Plot the steady-state function and time constant for this new current.\nHINT: In Table A2 of this publication, the authors provide the forward rate function (\\(\\alpha[V]\\)) and backward rate function (\\(\\beta[V]\\)) for this current. Use these functions to compute the steady-state function and time constant, and plot both versus V.\n\n\n2. Update the HH model to include this new current.\nHINT: Update the HH model to accept three inputs: HH(I0, T0, gB0), where gB0 is the maximal conductance of the new current.\nHINT: Update the HH model to return six outputs: return V,m,h,n,B,t, where B is the gate variable of the new current.\n\n\n3. Find parameter settings so that the model produces bursting activity.\nHINT: Fix I0=10 and T0=500 and vary the maximal conductance of the new current, gB0, until you find a value that supports bursting in the voltage.\nHINT: Plot the voltage V and the new current gate B to visualize how the dynamics behave.\n\n\n4. Compute the spectrum to characterize the dominant rhythms.\nHINT: Be sure to carefully define T.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef alphaM(V):\n    return (2.5-0.1*(V+65)) / (np.exp(2.5-0.1*(V+65)) -1)\n\ndef betaM(V):\n    return 4*np.exp(-(V+65)/18)\n\ndef alphaH(V):\n    return 0.07*np.exp(-(V+65)/20)\n\ndef betaH(V):\n    return 1/(np.exp(3.0-0.1*(V+65))+1)\n\ndef alphaN(V):\n    return (0.1-0.01*(V+65)) / (np.exp(1-0.1*(V+65)) -1)\n\ndef betaN(V):\n    return 0.125*np.exp(-(V+65)/80)\n\ndef alphaB(V):\n    return \"SOMETHING\"\n\ndef betaB(V):\n    return \"SOMETHING\"\n\ndef HHB(I0,T0,gB0):\n    \"SOMETHING\""
  },
  {
    "objectID": "Aperiodic_Exponent_Lab.html",
    "href": "Aperiodic_Exponent_Lab.html",
    "title": "Aperiodic exponent example",
    "section": "",
    "text": "Let’s try this example code.\n\n# Import required code for visualizing example models\nfrom fooof import FOOOF\nfrom fooof.sim.gen import gen_power_spectrum\nfrom fooof.sim.utils import set_random_seed\nfrom fooof.plts.spectra import plot_spectra\nfrom fooof.plts.annotate import plot_annotated_model\n\n\n# Set random seed, for consistency generating simulated data\nset_random_seed(21)\n\n# Simulate example power spectra\nfreqs1, powers1 = gen_power_spectrum([3, 40], [1, 1],\n                                     [[10, 0.2, 1.25], [30, 0.15, 2]])\nfreqs2, powers2 = gen_power_spectrum([1, 150], [1, 125, 1.25],\n                                     [[8, 0.15, 1.], [30, 0.1, 2]])\n\n\n# Initialize power spectrum model objects and fit the power spectra\nfm1 = FOOOF(min_peak_height=0.05, verbose=False)\nfm2 = FOOOF(min_peak_height=0.05, aperiodic_mode='knee', verbose=False)\nfm1.fit(freqs1, powers1)\nfm2.fit(freqs2, powers2)\n\n\n# Plot one of the example power spectra\nplot_spectra(freqs1, powers1, log_powers=True,\n             color='black', label='Original Spectrum')\n\n\n# Plot an example power spectrum, with a model fit\nfm1.plot(plot_peaks='shade', peak_kwargs={'color' : 'green'})\n\n\n# Plot an annotated version of the power spectrum model\nplot_annotated_model(fm1, annotate_aperiodic=False)\n\n\n# Report: fit the model, print the resulting parameters, and plot the reconstruction\nfm1.report()"
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Introduction to Python for the practicing neuroscientist",
    "section": "",
    "text": "To be frank: this notebook is rather boring. In this class, we will use the software package Python. The best way to learn new software (and probably most things) is when motivated by a particular problem. Would you read assembly instructions for furniture you do not plan to own? Probably not. In other notebooks we will pursue specific questions driven by neuronal data, and use our desire to understand these data to motivate the development and application of computational methods. But not in this notebook. Here, we focus on basic coding techniques and principles in Python in the abstract, without motivation. You - poor learner - must trust that these ideas and techniques will eventually be useful. We begin by dipping our toe into the Python pool, and learning the basic strokes; the fun and interesting parts in the “real world” of neuronal data happen later.\nLet us delay no further. In the following examples, you are asked to execute code in Python. If your Python experience is limited, you should actually do this, not just read the text below. If you intend to ignore this advice - and not execute the code in Python - then instead walk to the local coffee shop, get a double espresso, and return to attempt these examples.\nThis notebook follows in spirit and sometimes in detail notebook 2 of MATLAB for Neuroscientists, an excellent reference for learning to use MATLAB in neuroscience with many additional examples. If you have not used Python before, there are many excellent resources online (e.g., the Python Data Science Handbook).\n\nStarting Python\nThere are two ways to interact with this notebook. First, you could run it locally on your own computer using Jupyter. This is an excellent choice, because you’ll be able to read, edit, and excute the Python code directly and you can save any changes you make or notes that you want to record. The second way is to open this notebook in your browser and execute the examples directly in your browser, without installing additional software on your computer. In any case, we encourage you to execute each line of code in this file!\n\n\n\n\n\n\nNote\n\n\n\nThroughout this notebook, we assume that you are running Python 3. Most of the functions used here are the same in Python 2 and 3. One noteable exception however is division. If you are using Python 2, you will find that the division operator / actually computes the floor of the division if both operands are integers (i.e., no decimal points). For example, in Python 2, 4/3 equals 1. While, in Python 3, 4/3 equals 1.333.\nWe encourage you to use Python 3 for the sake of compatibility with this notebook, as well as for compatibility with future releases of Python.\n\n\n\n\nOn-ramp: analysis of neural data in Python\nWe begin this notebook with an “on-ramp” to analysis in Python. The purpose of this on-ramp is to introduce you immediately to some aspects of Python. You may not understand all aspects of the Python language here, but that’s not the point. Instead, the purpose of this on-ramp is to illustrate what can be done. Our advice is to simply run the code below and see what happens…\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Try to read the code above. Can you see how it loads data, extracts useful information to print, then selects an interval of data to plot?\nA: If you’ve never used Python before, that’s an especially difficult question. Please continue on to learn more!\n\n\n\n\n\nExample 1: Python is a calculator\nExecute the following commands in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What does Python return? Does it make sense?\n\n\n\n\n\nExample 2. Python can compute complicated quantities.\nEnter the following command in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Does this answer make sense?\n\n\n\n\n\n\n\n\n\nQ: Can you use parentheses to change the answer?\n\n\n\n\n\nExample 3. Python has useful built in functions.\nA function is a program that operates on arguments. Standard math functions and variables (and other useful things) can be accessed from the math and numpy modules. To use the math and numpy modules, we must first import both:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nIn this style, we indicate which module, or namespace, contains the function we want to call: x = np.arange(10) or plt.plot(x, y).\n\n\nYou will often begin your data analysis with import statements, to load the functionality you need. We can now call functions from math using numpy.*. For example,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAbove, sin is the sine function. It operates on the argument 2*pi. Notice that, once we have imported the numpy module, Python knows the value of pi. Here’s another example function that operates on arguments:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What is math.atan?\nA: To answer this, try using Python Help. To start the Python Help, simply put a ? at the end of math.atan and then run this code block.\n\n\n\n\n\nCode\nmath.atan?\n\n\nYou should see a description of the function pop up at the bottom of the window.\n\n\n\n\n\n\nNote\n\n\n\nPython Help is extremely useful, but may not work in a web browser. You can always look there when you have questions about a function, or search the internet for help, i.e., google it.\n\n\n\n\nExample 4. We can use Python to define lists of numbers.\nIn Python, there are several different data structures that are designed to store more than one element. Here we will focus on the array data structure, but if you are curious to know how and when to use other structures, there is a good explanation here. Let’s define an array:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 5. We can manipulate arrays by scalars.\nA scalar is a single number. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What do you find?\nA: Notice that the scalar operates on each element of the array.\n\n\n\n\n\nExample 6. We can manipulate arrays with arrays.\nLet’s create an array and multiply it by itself,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What does this return?\nA: We see that the operator * performs element-by-element multiplication of the values in array a.\n\n\n\n\n\nExample 7. More examples of manipulating arrays with arrays.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What operation does np.multiply() perform?\n\n\n\n\n\nExample 8. We can probe the variables we’ve defined in Python.\nTo see a list of the variables you’ve defined, type who or whos in a code block by themselves. Notice whos provides more information.\n\n\nCode\nwho\n\n\nInteractive namespace is empty.\n\n\n\n\nCode\nwhos\n\n\nInteractive namespace is empty.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe functions who and whos can be extremely useful, but may not work in a web browser.\n\n\n\n\nExample 9. Determine the dimensions of an array\nTo examine the dimensions of an array, we can ask for the shape,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe find that the shape of a is (1,4) or 1 row and 4 columns. Notice we have two options to execute the shape function:\n\nIn a.shape we return the attribute shape of the variable a.\nIn np.shape(a) we apply the function shape from numpy to the variable a.\n\nThe result is equivalent.\n\n\nExample 10. Sometimes we need to reset the workspace\nBy doing so, we get rid of all the variables. To do so, type %reset and enter y\n\n\nCode\n%reset\n\n\n\n\n\n\n\n\nQ. What command could we use to confirm there are no variables in the workspace?\nA. Consider who.\n\n\n\n\n\nCode\nwho\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe %reset command is an example of a magic. Magics are commands that start with the % symbol and use a language other than Python. They are only available in the notebook environment. In fact, the set of magics that is available is specific to the notebook kernel. This means that if you have a Jupyter notebook running a Ruby kernel the magics will be different.\n\n\n\n\nExample 11. We can define matrices in Python.\nA matrix is an array with more than one dimensio. Consider the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis creates a matrix with two rows and three columns. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Can you see the two rows and three columns?\n\n\n\nWe can manipulate matrices like we manipulate vectors.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 12. Indexing matrices and vectors.\nMatrices and vectors are arrays of numbers, and sometimes we want to access individual elements or small subsets of these lists. That’s easy to do in Python. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPython indexes from 0 (like C, C++, Java, and unlike MATLAB and Fortran which start at 1). To access the 2nd element of a or b, type a[1] / b[1]. We’ll be a bit fancier with our printing now to distinguish variables. Calling str(a) converts the variable a to a string that can be printed easily. Adding two strings just concatenates them: \"hi\" + \" bye\" = \"hi bye\".\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Do the results make sense? How would you access the 4th element of each vector?\n\n\n\nWe can combine a and b to form a matrix with a as the first row and b as the second. Note that we apply the function array() to the list [a,b], which it converts to a matrix.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo learn the size (or shape) of c we use shape():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe shape of c is [2 5]. It has two rows and five columns. To access the individual element in the 1st row and 4th column of c, type c[0,3]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWe access matrices using ‘row, column’ notation. So c[0,3] means print the element in row 0, column 3 of c.\n\n\n\n\n\n\n\nQ. How would you print all rows in the 2nd column of c?\n\n\n\n\n\nExample 13: We can find subsets of elements in matrices and vectors.\nOften we are interested in only some of the elements of a matrix or vector. For example, we might want to look at the data from a single experimental trial which is stored in a particular row of a matrix. Alternatively, we might want to find out when the values in a time series cross a given boundary. Doing this is simple in Python.\n\nSlicing\nSlicing means that we want to look at a specific portion of a vector or matrix, for example, the first row of a matrix. We will continue with the matrix c from the previous example. The notation ‘:’ means ‘all indices’. To access all columns in the entire first row of c, type c[0,:]. To access the 2nd thru 4th columns of the first row of c, type c[0,1:4].\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThe notation 1:4 means all integers from 1 up to, but not including 4, which in this case gives columns 1, 2, and 3.\n\nLeaving out the number before the colon tells Python to start at index 0. Leaving out the number after the colon tells Python to continue all the way to the end.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can also tell Python how to step through the indices. To access only the even columns of c, we can use the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis code tells Python to start at 0, continue to the end, and step by 2. The result should be the values in row 0, columns 0, 2, and 4 of c. We could write this explicitly as c[0,0:5:2].\n#### Selecting elements that satisfy a condition Sometimes we’re interested in locating particular values within a matrix or vector. As an example, let’s first define a vector.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Calculate the shape of a. What is the maximum value of a? Hint: Use the max() function.\n\n\n\nNow let’s find all values in a that exceed 10.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis is called logical indexing, let’s look at what a&gt;10 returns:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen we index a using this array lgIdx we get back only the entries in a corresponding to True, as above:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSometimes we want to know the actual indices in a where a &gt; 10. We can get them using the nonzero() array method, which returns the index of all entries that were True, or non-zero.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThe command nonzero() can be used as both a function and a method. A method is called by adding it after the object it is meant to operate on with a period in between ( lgIdx.nonzero() ). A function is called with the argument explicitly provided inside the parentheses ( nonzero(lgIdx) ). Basically, a function and a method do the same thing, but a function needs to be given an argument, while a method assumes that the argument is the object that the method is attached to. Note that if we use nonzero() as a function, we need to tell it to look in NumPy for the definition (i.e. add `` at the beginning of the function call).\n\nNow we have another way to select the desired elements of a:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can use these two types of indexing to change subsets of the values of a.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How does a change in the first and second print statements?\n\n\n\nWe can perform these same logical operations for a matrix,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNotice that the last line collapses the True entries to an array, ordered by row and then by column. If you’ve used MATLAB, this is the opposite of what it does!\n\n\n\n\nExample 14: Plotting data in Python.\nIt’s not easy to look at lists of numbers and gain an intuitive feeling for their behavior, especially when the lists are long. In these cases, it’s better to visualize the lists of numbers by plotting them. Consider\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Looking at the values in ‘y’ printed above, can you tell what’s happending?\nA. Not really … let’s visualize y vs x instead.\n\n\n\n\nmatplotlib\nTo visualize y versus x let’s plot it. To do so, let’s first import some basic plotting routines from matplotlib, which provides a nice 2D plotting library. We’ll also tell Python to show matplotlib graphics inline, in this notebook.\nLet’s start by plotting a simple example for x and y,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does the plot above make sense for the variables x and y?\n\n\n\nNow, let’s go back to the definitions of x and y that we started this example with and plot y versus x.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe plot of x versus y should look a bit jagged, and not smooth like a sinusoid. To make the curve smoother, let’s redefine x as,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Compare this definition of x to the definition above. How do these two definitions differ?\n\n\n\n\n\n\n\n\n\nQ. What is the size of x? Does this make sense?\n\n\n\nNow let’s replot the sine function.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does this plot make sense, given your knowledge of x, y, and trigonometry?\n\n\n\n\n\n\nExample 15: What if we want to compare several functions?\nContinuing the example in the previous section, let’s define a second vector\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nand plot it:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’d now like to compare the two variables y and z. To do this, let’s plot both vectors on the same figure, label the axes, and provide a legend,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that we’ve included a third input to the function plot. Here the third input tells Python to draw the curve in a particular color: 'r' for red. There are many options we can use to plot; to see more, check out the documentation for plot.\nWe can also label the axes, give the figure a title, and provide a legend,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo futher edit this plot, you might decide - for example - that the font size for the labels is too small. We can change the default with:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 16: We can make random numbers in Python.\nTo generate a single Gaussian random number in Python, use the function in the NumPy random module.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s generate a vector of 1000 Gaussian random numbers:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n… and look at a histogram of the vector:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does this histogram make sense? Is it what you expect for a distribution of Gaussian random variables?\n\n\n\n\nSee Python Help (hist?) to learn about the function hist().\n\n\n\nExample 17: Sampling randomly from a vector\nUsing the random module from numpy one can also take a random sample from a vector. Let’s take 5 random samples from the vector “r” generated in example 16.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThat’s horrible code! All I did was cut and paste the same thing four times. As a general rule, if you’re repeatedly cutting and pasting in code, what you’re doing is inefficient and typically error prone. There’s a much more elegant way to do this, and it involves making a for loop. Consider:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow let’s declare a for loop where k successively takes the values 1, then 2, then 3, …, up to 5. Note, any code we want to execute as part of the loop must be indented one level. The first line of code that is not indented, in this case show() below, executes after the for loop completes\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe small section of code above replaces all the cutting-and-pasting. Instead of cutting and pasting, we update the definition of y with different values of k and plot it within this for-loop.\n\n\n\n\n\n\nQ. Spend some time studying this for-loop. Does it make sense?\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nImportant: Python uses indentation to define for loops.\n\n\n\n\nExample 19: Defining a new function.\nWe’ve spent some time in this notebook writing and executing code. Sometimes we’ll need to write our own Python functions. Let’s do that now.\nOur function will do something very simple: it will take as input a vector and return as output the vector elements squared plus an additive constant.\nIf have a vector, v, and a constant, b, we would like to call:\nvsq = my_square_function(v, b)\nThis won’t work! We first need to define my_square_function. Let’s do so now,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe function begins with the keyword def followed by the function name and the inputs in parentheses. Notice that this first line ends with a colon :. All of the function components that follow this first line should be indented one level. This is just like the for loop we applied earlier; the operations performed by the for loop were indented one leve.\n\nWhen defining the function, the code the function executes should be indented one level.\n\nThe text inside triple quotes provides an optional documentation string that describes our function. While optional, including a ‘doc string’ is an important part of making your code understandable and reuseable.\nThe keyword return exits the function, and in this case returns the expression x * x + c. Note that a return statement with no arguments returns None, indicating the absence of a value.\nWith the function defined, let’s now call it. To do so we first define the inputs, and then run the function, as follows:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Try to make a function, my_power, so that y = power(x,n) evaluates \\(y = x^n\\), (in Python you can use x**n to take the power)\n\n\n\n\n\nExample 20: Load data into Python\nFor our last example let’s load a data file on the web in the .csv format into Python.\nTo do so, let’s first import the pandas module,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s load a data file using the function read_csv,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe variable df that holds the loaded data is a Python DataFrame. We can think of it as a simple table that holds our data.\nLet’s print it,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe see that the columns in the dataframe consist of two variables: d and t. Our collaborator who provided the data tells us that these correspond to the voltage recording (d) and a time axis (t) for her data.\nLet’s define variables to hold the data corresponding to each key,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nHere we convert the data in each column to a numpy array, because we’d (probably) like numpy to function on these values.\n\n\nNow, let’s plot the LFP data versus the time axis,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 21: Compute statistics and compare\nContributed by @mateouma\nLet’s do some statistics. First, our standard imports.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWith numpy, we can find the mean and standard deviation of our LFP data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s use numpy to randomly generate numbers according to a normal distribution with the same mean and standard deviation as the LFP data. The syntax is np.random.normal(mean, sd, size), where mean, sd, and size are variables or numbers.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can use a histogram to compare the distribution of the data with a normal distribution with the same mean and standard deviation.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAs we can see, our data doesn’t look normally distributed, but in practice we should use a statistical test to make this assessment.\n\n\nExample 22: Recursion (courtsey of marieshi)\nLet’s consider a classic mathematical sequence: the Fibonacci sequence. This is a sequence that starts with 0 and 1, and each number is the sum of the preceding two numbers in the sequence.\nLet’s use this sequence to expand our knowledge of functions.\nWe use recursive functions when we want to call the function itself within the function.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can think of recursive functions algorithmically: it usually starts with one or more base cases, or the simplest form of the function. This defines the behavior and serve as an anchor.\nNext are the recursive calls, which simplifies the problem iteratively, usually by calling the function back onto itself.\n\n\n\n\n\n\nQ. What is the difference between using recursion and loops in this case? Do you see any benefits?\n\n\n\nRecursion tends to be most functional when analyzing tree or nested structures.\nFor example, if you are writing code and have a lot of parantheses you can’t keep track of, we can use recursion to see if they are balanced.\nTo keep this a bit simpler, let’s pretend that you have extracted all the parantheses and just need to check if a string of open or closed parantheses are balanced.\nFor example, () is balanced, )))((( or (() are not.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s test our function out!\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "Coherence_Lab_Part_2.html",
    "href": "Coherence_Lab_Part_2.html",
    "title": "Coherence Part 2 (Two noise signals, again)",
    "section": "",
    "text": "# Load modules we'll need.\n\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram"
  },
  {
    "objectID": "Coherence_Lab_Part_2.html#make-two-noise-signals-with-multiple-trials",
    "href": "Coherence_Lab_Part_2.html#make-two-noise-signals-with-multiple-trials",
    "title": "Coherence Part 2 (Two noise signals, again)",
    "section": "Make two noise signals, with multiple trials",
    "text": "Make two noise signals, with multiple trials\n\nN = 1000;\nK = 100;\ndt= 0.001;\nT = N*dt;\nx = np.random.randn(K,N)\ny = np.random.randn(K,N)\nt = np.arange(0,N)*dt\n\nplt.plot(t,x[0,:])\nplt.plot(t,y[0,:])\nplt.xlabel('Time [s]');"
  },
  {
    "objectID": "Coherence_Lab_Part_2.html#visualize-the-data-across-all-trials",
    "href": "Coherence_Lab_Part_2.html#visualize-the-data-across-all-trials",
    "title": "Coherence Part 2 (Two noise signals, again)",
    "section": "Visualize the data across all trials",
    "text": "Visualize the data across all trials\n\nplt.imshow(x,                             # ... and show the image,\n           extent=[min(t), max(t), K, 1],  # ... with meaningful axes,\n           aspect='auto')                  # ... and a nice aspect ratio\nplt.xlabel('Time [s]')\nplt.ylabel('Trial #');\nplt.title('All trials from E1');"
  },
  {
    "objectID": "Coherence_Lab_Part_2.html#compute-the-cross-covariance-averaged-across-trials",
    "href": "Coherence_Lab_Part_2.html#compute-the-cross-covariance-averaged-across-trials",
    "title": "Coherence Part 2 (Two noise signals, again)",
    "section": "Compute the cross-covariance, averaged across trials",
    "text": "Compute the cross-covariance, averaged across trials\n\ncc_xy = \"SOMETHING\"                          # Compute cc for each trial, \ncc_xy = np.mean(cc_xy,0)                     # ... average over trials,\nlags = np.arange(-N + 1, N)                  # ... create a lag axis,\nplt.plot(lags * dt, cc_xy)                   # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Trial averaged cross-covariance');\nplt.ylim([-0.1, 1]);"
  },
  {
    "objectID": "Coherence_Lab_Part_2.html#compute-the-coherence",
    "href": "Coherence_Lab_Part_2.html#compute-the-coherence",
    "title": "Coherence Part 2 (Two noise signals, again)",
    "section": "Compute the coherence",
    "text": "Compute the coherence\n\n# Fourier transforms.\nXf = \"SOMETHING\"  # Compute Fourier transform of x for each trial\nYf = \"SOMETHING\"  # Compute Fourier transform of y for each trial\n\n# Auto- and cross-spectra.\nSxx = \"SOMETHING\"  # Spectrum of x trials\nSyy = \"SOMETHING\"  # ... and y trials\nSxy = \"SOMETHING\"  # ... and the cross spectrum\n\n# Trial average.\nSxx = np.mean(Sxx,0)\nSyy = np.mean(Syy,0)\nSxy = np.mean(Sxy,0)\n\n# Calculate coherence.\ncohr = \"SOMETHING\"\n\nf = np.fft.fftfreq(N, dt)               # Define a frequency axis.\nplt.plot(f, cohr.real)                  # Plot the coherence.\nplt.ylim([0, 1.1])                      # ... with y-axis scaled,\nplt.xlabel('Frequency [Hz]')            # ... and with axes labeled.\nplt.ylabel('Coherence')\nplt.title('Trial averaged coherence between two electrodes');"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_2b.html",
    "href": "Analyzing_Rhythms_Lab_2b.html",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "",
    "text": "# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n# Load the data.\ndata = loadmat('AC_Example.mat')  # Load the data,\n# Data available here\n# https://github.com/Mark-Kramer/BU-MA665-MA666/tree/master/Data\n#\nd = data['d'][0]                # ... from the first electrode.\nt = data['t'][0]              # Load the time axis\nN = np.size(d,0)              # Store number of observations.\ndt = t[1]-t[0]                # Store sampling interval."
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_2b.html#load-the-data-and-look-at-it.",
    "href": "Analyzing_Rhythms_Lab_2b.html#load-the-data-and-look-at-it.",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Load the data and look at it.",
    "text": "Load the data and look at it.\nQ. Do you see rhythms?\n\nConclusions\n\n\n\n\n\n# Code to compute the spectrum."
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_2b.html#compute-the-spectrum.",
    "href": "Analyzing_Rhythms_Lab_2b.html#compute-the-spectrum.",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Compute the spectrum.",
    "text": "Compute the spectrum.\nQ. What do you find? What rhythms are present in the data?\n\nConclusions\n\n\n\n\n\n# Code to compute the autocovariance."
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_2b.html#compute-the-autocovariance.",
    "href": "Analyzing_Rhythms_Lab_2b.html#compute-the-autocovariance.",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Compute the autocovariance.",
    "text": "Compute the autocovariance.\nQ. What do you find? Is it consistent with the spectrum?\n\nConclusions"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_2b.html#example-spectrum-ftautocovariance",
    "href": "Analyzing_Rhythms_Lab_2b.html#example-spectrum-ftautocovariance",
    "title": "Analyzing Rhythms Part 2b (Autocovariance)",
    "section": "Example: Spectrum = FT{Autocovariance}",
    "text": "Example: Spectrum = FT{Autocovariance}\nMake a simple signal.\n\ndt = 0.001\nN  = 1000\nt  = np.arange(0,N)*dt\nd  = np.sin(2*np.pi*10*t) + np.random.randn(N)\n\nCompute the autocovariance with a modifications: circular-shift the data\n\nrxx = [];\nlags = np.arange(-int(N/2),int(N/2));\nfor idx,L in enumerate(lags):\n    rxx = np.append(rxx, 1/N*np.sum(np.roll(d,L) * d))\nplt.plot(lags, rxx)\nplt.xlabel('Lags [indices]');\nplt.ylabel('Autocovariance rxx');\n\nCompute the spectrum via FT and directly from the data.\n\n# Compute the spectrum from the FT{rxx}\nSxx_via_rxx = 2*dt*np.fft.fft(rxx)\n\n# Compute the spectrum from the data.\nT   = t[-1];\nxf  = np.fft.fft(d);\nSxx = 2 * dt ** 2 / T * (xf * xf.conj()) \n\nplt.plot(10*np.log10(Sxx))\nplt.plot(10*np.log10(Sxx_via_rxx), 'o')\nplt.xlabel('Freq Index')\nplt.legend({'Direct Sxx', 'Sxx via rxx'})\nplt.xlim([0,150]);"
  },
  {
    "objectID": "Dont-Sync-2024/1. Introduction/Introduction_Python_Lecture.html",
    "href": "Dont-Sync-2024/1. Introduction/Introduction_Python_Lecture.html",
    "title": "NO!",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf = pd.read_csv(\"COLLAB_NAME/data/Rhythms_1.csv\")\nimport numpy as np\nx = np.zeros(1000)\nfrom numpy import *\nx = zeros(10)\nprint(x)\nimport numpy as temp\nx = temp.zeros(10)\nprint(x)"
  },
  {
    "objectID": "Dont-Sync-2024/1. Introduction/Introduction_Python_Lecture.html#challenge-1",
    "href": "Dont-Sync-2024/1. Introduction/Introduction_Python_Lecture.html#challenge-1",
    "title": "NO!",
    "section": "Challenge",
    "text": "Challenge\nWrite a function that takes two inputs (each a number) and returns their squared sum.\n\ndef my_squared_function(x,y):\n    return x**2 + y**2\n\n\nmy_squared_function(1,2)\n\n5"
  },
  {
    "objectID": "Dont-Sync-2024/13. SHO and Golden Rhythms/SHO_Lab-SOLUTION.html",
    "href": "Dont-Sync-2024/13. SHO and Golden Rhythms/SHO_Lab-SOLUTION.html",
    "title": "Damped harmonic oscillator example",
    "section": "",
    "text": "# Load necessary packages\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "Dont-Sync-2024/13. SHO and Golden Rhythms/SHO_Lab-SOLUTION.html#define-a-damped-harmonic-oscillator-noise",
    "href": "Dont-Sync-2024/13. SHO and Golden Rhythms/SHO_Lab-SOLUTION.html#define-a-damped-harmonic-oscillator-noise",
    "title": "Damped harmonic oscillator example",
    "section": "Define a damped harmonic oscillator + noise",
    "text": "Define a damped harmonic oscillator + noise\n\ndef damped_harmonic_oscillator(omega,beta,noise,T0):\n\n    dt = 0.01;\n    T  = int(np.ceil(T0/dt))\n\n    t = np.arange(0,T)*dt\n    F = np.zeros([T,1])         # Set up forcing,\n    F[int(0.25*T)] = 1;         # ... give it a kick 25% of way into simulation.\n    x = np.zeros([T,1])\n    y = np.zeros([T,1])\n\n    x[0]=0\n    y[0]=0\n    \n    for i in range(0,T-1):\n        x[i+1] = x[i] + dt*(y[i]);\n        y[i+1] = y[i] + dt*(-omega**2*x[i] - 2*beta*y[i] + F[i] + noise*np.random.randn());\n\n    return x,t"
  },
  {
    "objectID": "Dont-Sync-2024/13. SHO and Golden Rhythms/SHO_Lab-SOLUTION.html#simulate-the-model",
    "href": "Dont-Sync-2024/13. SHO and Golden Rhythms/SHO_Lab-SOLUTION.html#simulate-the-model",
    "title": "Damped harmonic oscillator example",
    "section": "Simulate the model",
    "text": "Simulate the model\n\nf     = 1;\nomega = 2*np.pi*f;\nbeta  = 1;\nnoise = 0;\nT0    = 10\nx,t   = damped_harmonic_oscillator(omega,beta,noise,T0);\nplt.plot(t,x);"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html",
    "title": "Make two noise signals, with multiple trials",
    "section": "",
    "text": "# Load modules we'll need.\n\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\nN = 1000;\nK = 100;\ndt= 0.001;\nT = N*dt;\nx = np.random.randn(K,N)\ny = np.random.randn(K,N)\nt = np.arange(0,N)*dt\n\nplt.plot(t,x[0,:])\nplt.plot(t,y[0,:])\nplt.xlabel('Time [s]');"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html#visualize-the-data-across-all-trials",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html#visualize-the-data-across-all-trials",
    "title": "Make two noise signals, with multiple trials",
    "section": "Visualize the data across all trials",
    "text": "Visualize the data across all trials\n\nplt.imshow(x,                             # ... and show the image,\n           extent=[min(t), max(t), K, 1],  # ... with meaningful axes,\n           aspect='auto')                  # ... and a nice aspect ratio\nplt.xlabel('Time [s]')\nplt.ylabel('Trial #');\nplt.title('All trials from E1');"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html#compute-the-cross-covariance-averaged-across-trials",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html#compute-the-cross-covariance-averaged-across-trials",
    "title": "Make two noise signals, with multiple trials",
    "section": "Compute the cross-covariance, averaged across trials",
    "text": "Compute the cross-covariance, averaged across trials\n\ncc_xy = 1/N*np.array([np.correlate(x[k,:],y[k,:], 'full') for k in range(0,K)]); # Compute cc for each trial, \ncc_xy = np.mean(cc_xy,0)                     # ... average over trials,\nlags = np.arange(-N + 1, N)                  # ... create a lag axis,\nplt.plot(lags * dt, cc_xy)                   # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Trial averaged cross-covariance');\nplt.ylim([-0.1, 1]);"
  },
  {
    "objectID": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html#compute-the-coherence",
    "href": "Dont-Sync-2024/9. Coherence/Coherence_Lab_Part_2-SOLUTION.html#compute-the-coherence",
    "title": "Make two noise signals, with multiple trials",
    "section": "Compute the coherence",
    "text": "Compute the coherence\n\n# Fourier transforms.\nXf = np.array([np.fft.fft(x0 - x0.mean()) for x0 in x])  # Compute Fourier transform of x for each trial\nYf = np.array([np.fft.fft(y0 - y0.mean()) for y0 in y])  # Compute Fourier transform of y for each trial\n\n# Auto- and cross-spectra.\nSxx = 2*dt**2/T * (Xf * np.conj(Xf))  # Spectrum of E1 trials\nSyy = 2*dt**2/T * (Yf * np.conj(Yf))  # ... and E2 trials\nSxy = 2*dt**2/T * (Xf * np.conj(Yf))  # ... and the cross spectrum\n\n# Trial average.\nSxx = np.mean(Sxx,0)\nSyy = np.mean(Syy,0)\nSxy = np.mean(Sxy,0)\n\n# Calculate coherence.\ncohr = np.abs(Sxy) / (np.sqrt(Sxx) * np.sqrt(Syy))\n\nf = np.fft.fftfreq(N, dt)                      # Define a frequency axis.\nplt.plot(f, cohr.real)               # Plot the coherence.\nplt.ylim([-0.1, 1.1])                      # ... with y-axis scaled,\nplt.xlabel('Frequency [Hz]')            # ... and with axes labeled.\nplt.ylabel('Coherence')\nplt.title('Trial averaged coherence between two electrodes');\n\nprint(np.min(cohr.real))\n\n0.0037302741713843204"
  },
  {
    "objectID": "Dont-Sync-2024/10. CFC/Untitled.html",
    "href": "Dont-Sync-2024/10. CFC/Untitled.html",
    "title": "BU MA665+MA666",
    "section": "",
    "text": "# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\n# Load the data.\ndata = loadmat('LFP-1.mat')      # Load the data,\nt    = data['t'][0]                   # ... extract t, the time variable,\nLFP  = data['LFP'][0]                 # ... and LFP, the voltage variable.\ndt   = t[1] - t[0]                    # Define the sampling interval,\nfNQ  = 1 / dt / 2                     # ... and Nyquist frequency. \n\n\nplt.plot(t,LFP)\nplt.xlim([30,31])\n\n\n\n\n\n\n\n\n\n# Compute the spectrum.\nT  = t[-1]\nN = np.size(LFP)\ndf = 1/T\nf0 = 1/dt\nfNQ= f0/2\nfaxis = np.arange(0, fNQ, df)\n\nX = np.fft.fft(LFP - np.mean(LFP))\nS = 2*dt**2/T * (np.conj(X)*X)\nS = S[0:int(N/2)]\n\nplt.plot(faxis, 10*np.log10(S))\nplt.xlabel('Freq [Hz]');\nplt.ylim([-80, 10])\nplt.xlim([0,200])\n\n/opt/anaconda3/lib/python3.12/site-packages/matplotlib/cbook.py:1699: ComplexWarning: Casting complex values to real discards the imaginary part\n  return math.isfinite(val)\n/opt/anaconda3/lib/python3.12/site-packages/matplotlib/cbook.py:1345: ComplexWarning: Casting complex values to real discards the imaginary part\n  return np.asarray(x, float)\n\n\n\n\n\n\n\n\n\n\nfrom scipy import signal\n\n# Low frequency band.\nWn = [4,8];                       # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVlo = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data.\n\n# High frequency band.\nWn = [75, 125];                      # Set the passband [??-??] Hz,\nn = 100;                            # ... and filter order,\n                                    # ... build the bandpass filter,\nb = signal.firwin(n, Wn, nyq=fNQ, pass_zero=False, window='hamming');\nVhi = signal.filtfilt(b, 1, LFP);   # ... and apply it to the data.\n\n\nplt.plot(t,LFP)\nplt.plot(t,Vlo)\nplt.plot(t,Vhi)\nplt.xlim([30, 31])\n\n\n\n\n\n\n\n\n\n# Compute the amplitude of Vhi and phase of Vlo.\n\nphi = np.angle(signal.hilbert(Vlo))\namp = np.abs(signal.hilbert(Vhi))\n\nplt.plot(t, Vlo)\nplt.plot(t, phi)\nplt.xlim([10, 11])\n\nplt.figure()\nplt.plot(t, Vhi)\nplt.plot(t, amp)\nplt.xlim([10, 11])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np_bins = np.arange(-np.pi, np.pi, 0.1)\n#print(p_bins)\namp_mean = np.zeros(len(p_bins)-1)\nfor k in range(np.size(p_bins)-1):\n    pL = p_bins[k]\n    pR = p_bins[k+1]\n    #print(pL, pR)\n    indices = (phi&gt;=pL) & (phi&lt;pR)\n    amp_mean[k] = np.mean(amp[indices])\n\nplt.plot(p_bins[:-1], amp_mean)"
  },
  {
    "objectID": "Dont-Sync-2024/14. Aperiodic Exponent/Aperiodic_Exponent_Lab.html",
    "href": "Dont-Sync-2024/14. Aperiodic Exponent/Aperiodic_Exponent_Lab.html",
    "title": "Aperiodic exponent example",
    "section": "",
    "text": "Let’s try this example:\nhttps://fooof-tools.github.io/fooof/auto_tutorials/plot_01-ModelDescription.html#sphx-glr-auto-tutorials-plot-01-modeldescription-py\n\n# Import required code for visualizing example models\nfrom fooof import FOOOF\nfrom fooof.sim.gen import gen_power_spectrum\nfrom fooof.sim.utils import set_random_seed\nfrom fooof.plts.spectra import plot_spectra\nfrom fooof.plts.annotate import plot_annotated_model\n\n\n# Set random seed, for consistency generating simulated data\nset_random_seed(21)\n\n# Simulate example power spectra\nfreqs1, powers1 = gen_power_spectrum([3, 40], [1, 1],\n                                     [[10, 0.2, 1.25], [30, 0.15, 2]])\nfreqs2, powers2 = gen_power_spectrum([1, 150], [1, 125, 1.25],\n                                     [[8, 0.15, 1.], [30, 0.1, 2]])\n\n\n# Initialize power spectrum model objects and fit the power spectra\nfm1 = FOOOF(min_peak_height=0.05, verbose=False)\nfm2 = FOOOF(min_peak_height=0.05, aperiodic_mode='knee', verbose=False)\nfm1.fit(freqs1, powers1)\nfm2.fit(freqs2, powers2)\n\n\n# Plot one of the example power spectra\nplot_spectra(freqs1, powers1, log_powers=True,\n             color='black', label='Original Spectrum')\n\n\n# Plot an example power spectrum, with a model fit\nfm1.plot(plot_peaks='shade', peak_kwargs={'color' : 'green'})\n\n\n# Plot an annotated version of the power spectrum model\nplot_annotated_model(fm1, annotate_aperiodic=False)\n\n\n# Report: fit the model, print the resulting parameters, and plot the reconstruction\nfm1.report()"
  },
  {
    "objectID": "Dont-Sync-2024/11. Gamma Models/Untitled.html",
    "href": "Dont-Sync-2024/11. Gamma Models/Untitled.html",
    "title": "BU MA665+MA666",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef alphaM(V):\n    return (2.5-0.1*(V+65)) / (np.exp(2.5-0.1*(V+65)) -1)\n\ndef betaM(V):\n    return 4*np.exp(-(V+65)/18)\n\ndef alphaH(V):\n    return 0.07*np.exp(-(V+65)/20)\n\ndef betaH(V):\n    return 1/(np.exp(3.0-0.1*(V+65))+1)\n\ndef alphaN(V):\n    return (0.1-0.01*(V+65)) / (np.exp(1-0.1*(V+65)) -1)\n\ndef betaN(V):\n    return 0.125*np.exp(-(V+65)/80)\n\ndef ing(I0,gI,tauI,T0):\n    dt = 0.01;\n    T  = int(np.ceil(T0/dt))  # [ms]\n    gNa0 = 120   # [mS/cm^2]\n    ENa  = 125;  # [mV]\n    gK0  = 36;   # [mS/cm^2]\n    EK   = -12;  # [mV]\n    gL0  = 0.3;  # [mS/cm^2]\n    EL   = 10.6; # [mV]\n\n    t = np.arange(0,T)*dt\n    V = np.zeros([T,1])\n    m = np.zeros([T,1])\n    h = np.zeros([T,1])\n    n = np.zeros([T,1])\n\n    # Initialize variables to hold the synapse results\n    s = np.zeros(T)\n\n    V[0]=-70.0\n    m[0]=0.05\n    h[0]=0.54\n    n[0]=0.34\n    s[0]=0.0\n\n    for i in range(0,T-1):\n        V[i+1] = V[i] + dt*(gNa0*m[i]**3*h[i]*(ENa-(V[i]+65)) + gK0*n[i]**4*(EK-(V[i]+65)) + gL0*(EL-(V[i]+65)) + I0 + gI*s[i]*(-80 - V[i]))\n        m[i+1] = m[i] + dt*(alphaM(V[i])*(1-m[i]) - betaM(V[i])*m[i]);\n        h[i+1] = h[i] + dt*(alphaH(V[i])*(1-h[i]) - betaH(V[i])*h[i]);\n        n[i+1] = n[i] + dt*(alphaN(V[i])*(1-n[i]) - betaN(V[i])*n[i]);\n        s[i+1] = s[i] + dt * (((1 + np.tanh(V[i] / 10)) / 2) * (1 - s[i]) / 0.5 - s[i] / tauI)  # Update s\n    return V,s,t\n\n\nI0   = 0;    #Set the input drive to excite the cell.\ngI   = 20;     #Turn off inhibitory synapse, to start.\ntauI = 10;    #Set decay time of inhibitory synapse to 10ms.\nT0   = 100;   #Simulate for 100 ms.\n\n[V,s,t] = ing(I0,gI,tauI,T0)\nplt.subplot(2,1,1)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');\nplt.subplot(2,1,2)\nplt.plot(t,s,'r'); plt.xlabel('Time [ms]'); plt.ylabel('Inhibitory synaptic gate');\n\n/var/folders/mt/qz9sczyj4ys72smgdmwl7dc00016ry/T/ipykernel_69622/2857709991.py:49: DeprecationWarning: Conversion of an array with ndim &gt; 0 to a scalar is deprecated, and will error in future. Ensure you extract a single element from your array before performing this operation. (Deprecated NumPy 1.25.)\n  s[i+1] = s[i] + dt * (((1 + np.tanh(V[i] / 10)) / 2) * (1 - s[i]) / 0.5 - s[i] / tauI)  # Update s"
  },
  {
    "objectID": "Dont-Sync-2024/12. Bursting Models/Bursting_Lab-SOLUTION.html",
    "href": "Dont-Sync-2024/12. Bursting Models/Bursting_Lab-SOLUTION.html",
    "title": "Bursting Neuron",
    "section": "",
    "text": "The goal in this notebook is to update the HH equations to include a new (slow) current and produce bursting activity.\nTo do so, start with the HH code available here.\nUpdate the HH model to include the \\(\\bf{g_K-}\\)“M” current listed in Table A2 of this publication.\nIn the code below, we’ll use the variable B to define the gate for this current."
  },
  {
    "objectID": "Dont-Sync-2024/12. Bursting Models/Bursting_Lab-SOLUTION.html#challenges",
    "href": "Dont-Sync-2024/12. Bursting Models/Bursting_Lab-SOLUTION.html#challenges",
    "title": "Bursting Neuron",
    "section": "Challenges",
    "text": "Challenges\n\n1. Plot the steady-state function and time constant for this new current.\nHINT: In Table A2 of this publication, the authors provide the forward rate function (\\(\\alpha[V]\\)) and backward rate function (\\(\\beta[V]\\)) for this current. Use these functions to compute the steady-state function and time constant, and plot both versus V.\n\n\n2. Update the HH model to include this new current.\nHINT: Update the HH model to accept three inputs: HH(I0, T0, gB0), where gB0 is the maximal conductance of the new current.\nHINT: Update the HH model to return six outputs: return V,m,h,n,B,t, where B is the gate variable of the new current.\n\n\n3. Find parameter settings so that the model produces bursting activity.\nHINT: Fix I0=10 and T0=500 and vary the maximal conductance of the new current, gB0, until you find a value that supports bursting in the voltage.\nHINT: Plot the voltage V and the new current gate B to visualize how the dynamics behave.\n\n\n4. Compute the spectrum to characterize the dominant rhythms.\nHINT: Be sure to carefully define T.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef alphaM(V):\n    return (2.5-0.1*(V+65)) / (np.exp(2.5-0.1*(V+65)) -1)\n\ndef betaM(V):\n    return 4*np.exp(-(V+65)/18)\n\ndef alphaH(V):\n    return 0.07*np.exp(-(V+65)/20)\n\ndef betaH(V):\n    return 1/(np.exp(3.0-0.1*(V+65))+1)\n\ndef alphaN(V):\n    return (0.1-0.01*(V+65)) / (np.exp(1-0.1*(V+65)) -1)\n\ndef betaN(V):\n    return 0.125*np.exp(-(V+65)/80)\n\ndef alphaB(V):\n    return 0.02 / (1+ np.exp((-V-20)/5))\n\ndef betaB(V):\n    return 0.01 * np.exp((-V-43)/18)\n\ndef HHB(I0,T0,gB0):\n    dt = 0.01;\n    T  = int(np.ceil(T0/dt))  # [ms]\n    gNa0 = 120   # [mS/cm^2]\n    ENa  = 125;  # [mV]\n    gK0  = 36;   # [mS/cm^2]\n    EK   = -12;  # [mV]\n    gL0  = 0.3;  # [mS/cm^2]\n    EL   = 10.6; # [mV]\n\n    t = np.arange(0,T)*dt\n    V = np.zeros([T,1])\n    m = np.zeros([T,1])\n    h = np.zeros([T,1])\n    n = np.zeros([T,1])\n    B = np.zeros([T,1])  ##########################\n\n    V[0]=-70.0\n    m[0]=0.05\n    h[0]=0.54\n    n[0]=0.34\n    B[0]=0.0            #####################\n\n    for i in range(0,T-1):\n        V[i+1] = V[i] + dt*(gNa0*m[i]**3*h[i]*(ENa-(V[i]+65)) + gK0*n[i]**4*(EK-(V[i]+65)) + gL0*(EL-(V[i]+65)) + I0 + gB0*B[i]*(EK-(V[i]+65)));\n        m[i+1] = m[i] + dt*(alphaM(V[i])*(1-m[i]) - betaM(V[i])*m[i]);\n        h[i+1] = h[i] + dt*(alphaH(V[i])*(1-h[i]) - betaH(V[i])*h[i]);\n        n[i+1] = n[i] + dt*(alphaN(V[i])*(1-n[i]) - betaN(V[i])*n[i]);\n        B[i+1] = B[i] + dt*(alphaB(V[i])*(1-B[i]) - betaB(V[i])*B[i]);\n    return V,m,h,n,B,t\n\n\nV = np.arange(-100,50,1)\n\nxinfB = alphaB(V) / (alphaB(V) + betaB(V))\ntauB  =         1 / (alphaB(V) + betaB(V))\n\nplt.subplot(2,1,1)\nplt.plot(V,xinfB); plt.xlabel('Voltage [mV]'); plt.ylabel('xinfB')\nplt.subplot(2,1,2)\nplt.plot(V,tauB); plt.xlabel('Voltage [mV]'); plt.ylabel('tauB');\n\n\n\n\n\n\n\n\n\nI0 = 10;\nT0 = 500;\ngB0 = 7\n[V,m,h,n,B,t]=HHB(I0,T0,gB0)\nplt.subplot(2,1,1)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]')\n#plt.subplot(2,1,2)\n#plt.plot(t,B);\n\nText(0, 0.5, 'Voltage [mV]')\n\n\n\n\n\n\n\n\n\n\n# Decimate\nV = V.flatten()\nVd = sig.decimate(V, 50)\ntd  = t[::50]\ndt  = (td[2]-td[1])/1000; print(dt)\nf0  = 1/dt; print(f0)\n\n\n# \nimport scipy.signal as sig\nidx, _ = sig.find_peaks(Vd.flatten(), height=0)\ndn = np.zeros(np.shape(Vd))\ndn[idx] = 1\nplt.plot(td,dn)\nplt.xlim([0, 200])\n\n\nN   = np.size(t)\nT   = t[-1]/1000; print(T)\ndt  = (t[2]-t[1])/1000; print(dt)\nf0  = 1/dt\ndf  = 1/T;  print(df)\nfNQ = f0/2; print(fNQ)\n\n#x = V - np.mean(V);\n\n#x = x + 0*np.random.randn(np.size(x),1)\n\nX = np.fft.fft(V-np.mean(V));\nS = 2*dt**2/T * (X * np.conj(X))\nS = S[0:int(N/2)]\nfaxis = np.arange(0,fNQ,df)\n\nplt.plot(faxis, S.real)\n#plt.xlim([0, 200])\n\n0.99999\n1e-05\n1.000010000100001\n49999.99999999999"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Untitled.html",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Untitled.html",
    "title": "Make noise signal",
    "section": "",
    "text": "from scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\ndata = loadmat('EEG-1.mat')    # Load the EEG data\n# Data available here\n# https://github.com/Mark-Kramer/BU-MA665-MA666/tree/master/Data\n#\nEEG  = data['EEG'].reshape(-1) # Extract the EEG variable\nt    = data['t'][0]            # ... and the t variablea\n\n\nplt.plot(t,EEG)\nplt.xlabel('Time [s]')\nplt.ylabel('EEG');\n\n\n#dt = t[-1]/len(t)\ndt = t[2]-t[1]\nprint(dt)\n\n\nf0 = 1/dt\nprint(f0)\n\n\nN = len(t)\nprint(N)\n\n\nT = N*dt\nprint(T)\n\n\n# Q. What is the Nyquist frequency and frequency resolution?\nfNQ = f0/2\ndf  = 1/T\n\n# Q. What is the frequency axis?\nfj  = np.arange(0,fNQ,df)\n\n# Then, compute the Fourier transform \"by hand\".\nx = EEG\nX = np.ndarray(np.size(fj), complex);\nfor j in range( np.size(fj) ):\n    X[j] = np.sum(x * np.exp(-2*np.pi*1j*fj[j]*t) )\n\n# And the spectrum,\nSxx = 2*dt**2/T * (X * np.conjugate(X))\n\n# Plot it,\nplt.plot(fj, Sxx.real)\nplt.xlim([0, 100])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [mV^2/Hz]');\n\n\nx   = EEG\nX   = np.fft.fft(x)                        # Compute Fourier transform of x\nSxx = 2*dt**2/T * (X * np.conjugate(X))    # Compute spectrum\nSxx = Sxx[0:int(N / 2)].real               # Ignore negative frequencies\n\n\n# Plot it,\nplt.plot(fj, Sxx)\nplt.xlim([0, 100])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [mV^2/Hz]');\n\n\ndf  = 1/T                # Determine frequency resolution\nfNQ = f0/2                  # Determine Nyquist frequency\nfaxis = np.arange(0,fNQ,df)        # Construct frequency axis\n\n\nplt.plot(faxis, Sxx)\nplt.xlim([0, 100])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]');\n\n\nplt.figure()\nplt.plot(faxis, 10*np.log10(Sxx))   # Plot the spectrum in decibels.\n#plt.xlim([0, 100])                               # Select the frequency range.\nplt.ylim([-60, 0])                               # Select the decibel range.\nplt.xlabel('Frequency [Hz]')                     # Label the axes.\nplt.ylabel('Power [dB]');\n\n\nplt.figure()\nplt.plot(faxis, Sxx)                    # Plot the spectrum in decibels.\n#plt.xlim([df, 100])                                  # Select frequency range\nplt.ylim([10**-7, 0])                                   # ... and the decibel range.\nplt.xlabel('Frequency [Hz]')                         # Label the axes.\nplt.ylabel('Power [dB]');\n\n\nx_tapered  = np.hanning(N) * x\nplt.figure()\nplt.plot(t,x)\nplt.plot(t,x_tapered);\n\n\nxf_tapered  = np.fft.fft(x_tapered)                        # Compute Fourier transform of x.\nSxx_tapered = 2*dt**2/T*(xf_tapered*np.conj(xf_tapered))                        # Compute the spectrum,\nSxx_tapered = np.real(Sxx_tapered[:int(N / 2)])  # ... and ignore negative frequencies.\n\nplt.figure()\nplt.semilogx(faxis,10*np.log10(Sxx))         # Plot spectrum of untapered signal.  \nplt.semilogx(faxis,10*np.log10(Sxx_tapered)) # Plot spectrum vs tapered signal.\nplt.xlim([faxis[1], 100])                    # Select frequency range,\nplt.ylim([-70, 20])                          # ... and the power range.\nplt.xlabel('Frequency [Hz]')                 # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]')\n\n\n# Plot the spectrogram.\n\nFs = 1 / dt               # Define the sampling frequency,\ninterval = int(Fs)        # ... the interval size,\noverlap = int(Fs * 0.95)  # ... and the overlap intervals\n\n                          # Compute the spectrogram\nf0, t0, Sxx0 = spectrogram(\n    EEG,                  # Provide the signal,\n    fs=Fs,                # ... the sampling frequency,\n    nperseg=interval,     # ... the length of a segment,\n    noverlap=overlap)     # ... the number of samples to overlap,\nplt.pcolormesh(t0, f0, 10 * np.log10(Sxx0),\n               cmap='jet')# Plot the result\nplt.colorbar()            # ... with a color bar,\nplt.ylim([0, 70])             # ... set the frequency range,\nplt.xlabel('Time [s]')       # ... and label the axes\nplt.ylabel('Frequency [Hz]');\n\n\nN = 1000;\ndt= 0.001;\nT = N*dt;\nx = np.random.randn(N)\nt = np.arange(0,N)*dt\n\n#plt.plot(t,x)\n#plt.xlabel('Time [s]');\n\n\nlags  = np.arange(-N+1,N)\nac_xx = np.zeros(np.size(lags))\nfor index,L in enumerate(lags):\n    if L&gt;= 0:\n        ac_xx[index] = 1/N*np.sum( x[L:N]*x[0:N-L] )\n    else:\n        ac_xx[index] = 1/N*np.sum( x[0:N+L]*x[-L:N] )\nplt.plot(lags, ac_xx)                # ... and plot the result.\nplt.xlabel('Lag')\nplt.ylabel('Autocovariance');\n\n\nac_xx = 1/N*np.correlate(x,x,'full')\nplt.plot(lags, ac_xx)\n\n\n# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\n# Load the data.\ndata = loadmat('AC_Example.mat')  # Load the data,\n# Data available here\n# https://github.com/Mark-Kramer/BU-MA665-MA666/tree/master/Data\n#\nd = data['d'][0]                # ... from the first electrode.\nt = data['t'][0]              # Load the time axis\nN = np.size(d,0)              # Store number of observations.\ndt = t[1]-t[0]                # Store sampling interval.\n\n\nplt.plot(t,d)\n\n\nT  = t[-1]\ndf = 1/T\nf0 = 1/dt\nfNQ= f0/2\nfaxis = np.arange(0, fNQ, df)\n\nX = np.fft.fft(d - np.mean(d))\nS = 2*dt**2/T * (np.conj(X)*X)\nS = S[0:int(N/2)]\n\nplt.plot(faxis, S)\nplt.xlabel('Freq [Hz]')\n\n\nac = 1/N*np.correlate(d,d, 'full')\nlags = np.arange(-N+1,N)\nplt.plot(lags, ac);\n\n\ndt = 0.001\nN  = 1000\nt  = np.arange(0,N)*dt\nd  = 1*np.sin(2*np.pi*10.25*t) + 0.1*np.random.randn(N)\nplt.plot(t,d)\n\n\nrxx = [];\nlags = np.arange(-int(N/2),int(N/2));\nfor idx,L in enumerate(lags):\n    rxx = np.append(rxx, 1/N*np.sum(np.roll(d,L) * d))\nplt.plot(lags, rxx)\nplt.xlabel('Lags [indices]');\nplt.ylabel('Autocovariance rxx');\n\n\n# Compute the spectrum from the FT{rxx}\nSxx_via_rxx = 2*dt*np.fft.fft(rxx)\n\n# Compute the spectrum from the data.\nT   = t[-1];\nxf  = np.fft.fft(d);\nSxx = 2 * dt ** 2 / T * (xf * xf.conj()) \n\nplt.plot(10*np.log10(Sxx))\nplt.plot(10*np.log10(Sxx_via_rxx), 'o')\nplt.xlabel('Freq Index')\nplt.legend({'Direct Sxx', 'Sxx via rxx'})\nplt.xlim([0,150]);\n\n\n# Load modules we'll need.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nN  = 5000;                          # Number of bins.                   \ndt = 0.001;                         # Duration of each bin [s].\nT  = N*dt;                          # Total time of observation [s].\ntm = np.arange(0,N)*dt;             # Time axis for plotting\n\nlambda0 = 5                         # Average firing rate [Hz]\np0      = lambda0*dt;               # Probability of a spike in a time bin\ndn      = np.random.binomial(1,p0,N)# Create the spike train as \"coin flips\"\n\nplt.plot(tm, dn)                    # Plot it.\nplt.xlabel('Time [s]');\n\n\n# Compute the autocovariance.\n\nac_xx = 1/N*np.correlate(dn-np.mean(dn), dn-np.mean(dn), 'full')\nlags  = np.arange(-N + 1, N)        # Create a lag axis,\nplt.plot(lags * dt, ac_xx)          # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\nprint('lambda0*dt = ',lambda0*dt)  # Compare expected r_{nn}[0] to computed value.\nprint('r_{nn}[0]  = ',ac_xx[N-1])\n\n\n# Compute the spectrum.\n\nDj = np.fft.fft(dn - np.mean(dn))                            # Compute the FT,\nPj = 2*dt**2/T * (Dj * np.conj(Dj))                            # ... and the spectrum.\nf = np.fft.fftfreq(N, dt)                   # Create frequency axis.\nplt.plot(f, np.real(Pj))                    # Plot the spectrum.\nin_class_guess = 2*dt**2*lambda0                # And our guess from in-class analysis.\nplt.plot(f,in_class_guess*np.ones(N), 'b')\nplt.xlabel('Frequency [Hz]');\n\n\n# Repeat the entire simulation many times, and plot the average autocovariance and spectrum\n\nK  = 1000                                       # Number of times to repeat the simulation.\nlambda_est = np.zeros(K)                        # Vector to store estimate of lambda.\nP  = np.zeros([K,np.size(Pj)])                  # Matrix to store spectra,\nAC = np.zeros([K,2*N-1])                        # ... and AC.\n\nfor k in np.arange(K):                          # For each repeat,\n    dn = np.random.binomial(1,p0,N)             # ... create a new spike train.\n\n    lambda_est[k] = np.sum(dn)/T\n                                                # Compute the AC,\n    ac_xx = 1/N*np.correlate(dn-np.mean(dn), dn-np.mean(dn), 'full')\n    AC[k,:] = ac_xx                             # ... and save the result.\n    \n    Dj = np.fft.fft(dn - np.mean(dn))                            # Compute the FT,\n    Pj = 2*dt**2/T * (Dj * np.conj(Dj))                            # ... and the spectrum,\n    P[k,:] = Pj                                 # ... and save the result.\n\nplt.figure()                                    # Plot it.\nplt.plot(lags*dt, np.mean(AC,0))\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\n\nplt.figure()\nplt.plot(f, np.mean(P,0))                       # Plot the spectrum, averaged over repeats\nin_class_guess = 2*dt**2*np.mean(lambda_est)                  # Use lambda_est to compute our guess from in-class analysis.\nplt.plot(f,in_class_guess*np.ones(N), 'b')\nplt.xlabel('Frequency [Hz]');\n\n\nN  = 5000;                          # Number of bins.                   \ndt = 0.001;                         # Duration of each bin [s].\nT  = N*dt;                          # Total time of observation [s].\ntm = np.arange(0,N)*dt;             # Time axis for plotting\n\nlambda0 = 5                         # Average firing rate [Hz]\np0      = lambda0*dt;               # Probability of a spike in a time bin\ndn      = np.random.binomial(1,p0,N)# Create the spike train as \"coin flips\"\nrefractory_period = 10              # Add a refractory period\nfor i in np.arange(N):\n    if dn[i]==1:\n        dn[i+1:i+refractory_period] = 0\n\nplt.plot(tm, dn)                    # Plot it.\nplt.xlabel('Time [s]');\n\n\nac_xx = 1/N*np.correlate(dn-np.mean(dn), dn-np.mean(dn), 'full')\nlags  = np.arange(-N + 1, N)        # Create a lag axis,\nplt.plot(lags * dt, ac_xx)          # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\nprint('lambda0*dt = ',lambda0*dt)  # Compare expected r_{nn}[0] to computed value.\nprint('r_{nn}[0]  = ',ac_xx[N-1])\n\n\n# Compute the spectrum.\nDj = np.fft.fft(dn - np.mean(dn))                            # Compute the FT,\nPj = 2*dt**2/T * (Dj * np.conj(Dj))                            # ... and the spectrum.\nf = np.fft.fftfreq(N, dt)                   # Create frequency axis.\nplt.plot(f, np.real(Pj))                    # Plot the spectrum.\nin_class_guess = 2*dt**2*lambda0                # And our guess from in-class analysis.\nplt.plot(f,in_class_guess*np.ones(N), 'b')\nplt.xlabel('Frequency [Hz]');\n\n\n# Repeat the entire simulation many times, and plot the average autocovariance and spectrum\nK  = 1000                                       # Number of times to repeat the simulation.\nlambda_est = np.zeros(K)                        # Vector to store estimate of lambda.\nP  = np.zeros([K,np.size(Pj)])                  # Matrix to store spectra,\nAC = np.zeros([K,2*N-1])                        # ... and AC.\n\nfor k in np.arange(K):                          # For each repeat,\n    dn = np.random.binomial(1,p0,N)             # ... create a new spike train.\n    refractory_period = 100              # Add a refractory period\n    for i in np.arange(N):\n        if dn[i]==1:\n            dn[i+1:i+refractory_period] = 0\n            \n    lambda_est[k] = np.sum(dn)/T\n                                                # Compute the AC,\n    ac_xx = 1/N*np.correlate(dn-np.mean(dn), dn-np.mean(dn), 'full')\n    AC[k,:] = ac_xx                             # ... and save the result.\n    \n    Dj = np.fft.fft(dn - np.mean(dn))                            # Compute the FT,\n    Pj = 2*dt**2/T * (Dj * np.conj(Dj))                            # ... and the spectrum,\n    P[k,:] = Pj                                 # ... and save the result.\n\nplt.figure()                                    # Plot it.\nplt.plot(lags*dt, np.mean(AC,0))\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\nplt.xlim([-0.1, 0.1])\nplt.ylim([-0.0005, 0.001])\n\nplt.figure()\nplt.plot(f, np.mean(P,0))                       # Plot the spectrum, averaged over repeats\nin_class_guess = 2*dt**2*np.mean(lambda_est)                  # Use lambda_est to compute our guess from in-class analysis.\nplt.plot(f,in_class_guess*np.ones(N), 'b')\nplt.xlabel('Frequency [Hz]');\n\n\n# Load modules we'll need.\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\nN = 1000;\ndt= 0.001;\nT = N*dt;\nx = np.random.randn(N)\ny = np.random.randn(N)\nt = np.arange(0,N)*dt\n\nplt.plot(t,x)\nplt.plot(t,y)\nplt.xlabel('Time [s]');\n\n\ncc_xy = 1/N*np.correlate(x-np.mean(x), y-np.mean(y), 'full')\nlags  = np.arange(-N + 1, N)        # Create a lag axis,\nplt.plot(lags * dt, cc_xy)          # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Cross-covariance xy');\n\n\nX = np.fft.fft(d - np.mean(d))\nS = 2*dt**2/T * (np.conj(X)*X)\nS = S[0:int(N/2)]\n\nplt.plot(faxis, S)\nplt.xlabel('Freq [Hz]')\n\n\nXf = np.fft.fft(x - x.mean())           # Compute Fourier transform of x\nYf = np.fft.fft(y - y.mean())           # Compute Fourier transform of y\n\n# Compute the spectra\nSxx = 2*dt**2/T * (np.conj(Xf)*Xf)  # Spectrum of E1 trials\nSyy = 2*dt**2/T * (np.conj(Yf)*Yf)  # ... and E2 trials\nSxy = 2*dt**2/T * (np.conj(Xf)*Yf)  # ... and the cross spectrum\n\n# Compute the coherence.\ncohr = np.abs(Sxy) / (np.sqrt(Sxx) * np.sqrt(Syy))\n\n# Define a frequency axis.\nf = np.fft.fftfreq(N, dt)\n\n# Plot the result.\nplt.plot(f, cohr.real);\n\n\n# Load modules we'll need.\n\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\nN = 1000;\nK = 100;\ndt= 0.001;\nT = N*dt;\nx = np.random.randn(K,N)\ny = np.random.randn(K,N)\nt = np.arange(0,N)*dt\n\nplt.plot(t,x[1,:])\nplt.plot(t,y[1,:])\nplt.xlabel('Time [s]');\n\n\nplt.imshow(x,                             # ... and show the image,\n           extent=[min(t), max(t), K, 1],  # ... with meaningful axes,\n           aspect='auto')                  # ... and a nice aspect ratio\nplt.xlabel('Time [s]')\nplt.ylabel('Trial #');\nplt.title('All trials from x');\n\n\ncc_xy = 1/N*np.array([np.correlate(x[k,:]-np.mean(x[k,:]), y[k,:]-np.mean(y[k,:]), 'full') for k in range(0,K)])\ncc_xy = np.mean(cc_xy,0)                     # ... average over trials,\nlags = np.arange(-N + 1, N)                  # ... create a lag axis,\nplt.plot(lags * dt, cc_xy)                   # ... and plot the result.\nplt.xlabel('Lag [s]')\nplt.ylabel('Trial averaged cross-covariance');\nplt.ylim([-0.1, 1]);\n\n\n# Fourier transforms.\nXf = np.array( [np.fft.fft(x0 - x0.mean()) for x0 in x] )\nYf = np.array( [np.fft.fft(y0 - y0.mean()) for y0 in y] )\n\n# Auto- and cross-spectra.\nSxx = 2*dt**2/T * ( Xf * np.conj(Xf) ) \nSyy = 2*dt**2/T * ( Yf * np.conj(Yf) ) \nSxy = 2*dt**2/T * ( Xf * np.conj(Yf) ) \n\n# Trial average.\nSxx = np.mean(Sxx,0)\nSyy = np.mean(Syy,0)\nSxy = np.mean(Sxy,0)\n\n# Calculate coherence.\ncohr = np.abs(Sxy) / (np.sqrt(Sxx) * np.sqrt(Syy))\n\nf = np.fft.fftfreq(N, dt)               # Define a frequency axis.\nplt.plot(f, cohr.real)                  # Plot the coherence.\nplt.ylim([0, 1.1])                      # ... with y-axis scaled,\nplt.xlabel('Frequency [Hz]')            # ... and with axes labeled.\nplt.ylabel('Coherence')\nplt.title('Trial averaged coherence between two electrodes');\n\n\nimport scipy.io as io\nimport scipy.signal as signal\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Load the data and plot it.\ndata = io.loadmat('spikes-LFP-1.mat')   # Load the multiscale data,\ny = data['y']                                # ... get the LFP data,\nn = data['n']                                # ... get the spike data,\nt = data['t'].reshape(-1)                    # ... get the time axis,\nK = np.shape(n)[0]                           # Get the number of trials,\nN = np.shape(n)[1]                           # ... and the number of data points in each trial,\ndt = t[1]-t[0]                               # Get the sampling interval.\n\nplt.stem(t,n[0,:]);\nplt.plot(t,y[0,:], 'r')\nplt.xlabel('Time [s]');\n\n\n\n\n\n\n\n\n\ndef coherence(n,y,t):                           #INPUT (spikes, fields, time)\n    K = np.shape(n)[0]                          #... where spikes and fields are arrays [trials, time]\n    N = np.shape(n)[1]\n    T = t[-1]\n    SYY = np.zeros(int(N/2+1))\n    SNN = np.zeros(int(N/2+1))\n    SYN = np.zeros(int(N/2+1), dtype=complex)\n    \n    for k in np.arange(K):\n        yf = np.fft.rfft((y[k,:]-np.mean(y[k,:])))                   # FT of fields\n        nf = np.fft.rfft((n[k,:]-np.mean(n[k,:])))                   # FT of spikes\n        SYY = SYY + ( np.real( yf*np.conj(yf) ) )/K                  # Field spectrum\n        SNN = SNN + ( np.real( nf*np.conj(nf) ) )/K                  # Spike spectrum\n        SYN = SYN + (          yf*np.conj(nf)   )/K                  # Cross spectrum\n\n    cohr = np.abs(SYN) / np.sqrt(SYY) / np.sqrt(SNN)                 # Coherence\n    f = np.fft.rfftfreq(N, dt)                                       # Frequency axis for plotting\n    \n    return (cohr, f, SYY, SNN, SYN)\n\n\n[cohr, f, SYY, SNN, SYN] = coherence(n,y,t)\nplt.plot(f,cohr)\nplt.xlim([0, 100]); plt.xlabel('Frequency [Hz]'); plt.ylabel('Coherence');\n\n\n\n\n\n\n\n\n\ndef thinned_spike_train(n, thinning_factor):              # Thin the spike train (n) by the thinning_factor.\n    n_thinned = np.copy(n)                                # Make a copy of the spike train data.\n    for k in np.arange(K):                                # For each trial,\n        spike_times = np.where(n[k,:]==1)                 # ...find the spikes.\n        n_spikes = np.size(spike_times)                   # ...determine number of spikes.\n        spike_times_random = spike_times[0][np.random.permutation(n_spikes)]    # ...permute spikes indices,\n        n_remove=int(np.floor(thinning_factor*n_spikes))  # ... determine number of spikes to remove,\n        n_thinned[k,spike_times_random[1:n_remove]]=0     # remove the spikes.\n    return n_thinned\n\n\nplt.clf()\nplt.stem(t, n[0,:], 'k')\nplt.stem(t, thinned_spike_train(n,0.5)[0,:], 'r');\nplt.xlim([0.2, 0.3])\nplt.legend(['Original', 'Thinned']);\n\n\n\n\n\n\n\n\n\n[cohr, f, SYY, SNN, SYN] = coherence(n,y,t)  # Coherence for original spike train.\nplt.clf()\nplt.plot(f,cohr, 'b')\n[cohr, f, SYY, SNN, SYN] = coherence(thinned_spike_train(n,0.1),y,t)  # ... and for the thinned spike train.\nplt.plot(f,cohr, 'r')\nplt.xlim([40, 50])\nplt.legend(['Original', 'Thinned'])\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');\n\n\n\n\n\n\n\n\n\ndef sim_two_neurons(baseline_rate_A, baseline_rate_B, field_coupling_A, field_coupling_B):\n    K = 100                            # Number of trials.\n    N = 1000                           # Points per trial.\n    A = np.zeros([K,N])                # Array to hold spikes A.\n    B = np.zeros([K,N])                # Array to hold spikes B.\n    y = np.zeros([K,N])                # Array to hold field.\n    for k in np.arange(K):             # For each trial,\n        y[k,:] = np.sin(2*np.pi*t*10) + 0.1*np.random.randn(N)    # ... generate a field,\n        A[k,:] = np.random.binomial(1,0.001*np.exp(baseline_rate_A+field_coupling_A*y[k,:]))      # ... generate spikes #A that may depend on the field,\n        B[k,:] = np.random.binomial(1,0.001*np.exp(baseline_rate_B+field_coupling_B*y[k,:]))      # ... generate spikes #B that may depend on the field.\n    return A,B,y\n\n\nplt.figure()\nrate_A = 2.0;  coupling_A = 1             # Fix the rates and coupling to field for each neuron.\nrate_B = 0.2;  coupling_B = 1             # Simulate the two neurons.\nA,B,y = sim_two_neurons(rate_A, rate_B, coupling_A, coupling_B)\nn_trial = 0;                              # Select a trial to plot.\nplt.plot(t,A[n_trial,:])\nplt.plot(t,B[n_trial,:])\nplt.plot(t,y[n_trial,:])\nplt.legend([\"Neuron A\", \"Neuron B\", \"Field\"]);\n\nplt.figure()\n\n[cohr, f, SYY, SNN, SYN] = coherence(A,y,t); plt.plot(f,cohr)\n\n[cohr, f, SYY, SNN, SYN] = coherence(B,y,t); plt.plot(f,cohr)\n\nplt.xlim([0,20])\nplt.ylim([0,1])\nplt.legend(['Neuron A', 'Neuron B'])\nplt.xlabel('Frequency [Hz]')\nplt.ylabel('Coherence');"
  },
  {
    "objectID": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2a-SOLUTION.html",
    "href": "Dont-Sync-2024/8. Analyzing Rhythms/Analyzing_Rhythms_Lab_2a-SOLUTION.html",
    "title": "Load modules we’ll need.",
    "section": "",
    "text": "from scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\n\nMake the noise signal.\n\nN = 1000;\ndt= 0.001;\nT = N*dt\nx = np.random.randn(N)\nt = np.arange(0,N)*dt\n\nplt.plot(t,x)\nplt.xlabel('Time [s]');\n\n\n\n\n\n\n\n\n\n\nCompute the auto-covariance.\n\n# With function\nac_xx = 1 / N * np.correlate(x,x, 'full')     # Compute the covariance.\nlags  = np.arange(-N + 1, N)                  # Create a lag axis,\nplt.plot(lags, ac_xx, 'o')                         # ... and plot the result.\n\n# By hand\nlags  = np.arange(-N + 1, N)                  # Create a lag axis,\nac_xx_by_hand = np.zeros(np.size(lags))\nfor index, L in enumerate(lags):\n    #print(index,L)\n    if L&lt;0:\n        ac_xx_by_hand[index] = 1/N*np.sum(x[0:N+L]*x[-L:N])\n    else:\n        ac_xx_by_hand[index] = 1/N*np.sum(x[L:N] * x[0:N-L])\nplt.plot(lags, ac_xx_by_hand, '*')\n\n# By hand\n#ac_xx_by_hand_circ_shift = []\n#for L in np.arange(-N+1,N):\n#    xL = np.roll(x,L)\n#    ac_xx_by_hand_circ_shift = np.append(ac_xx_by_hand_circ_shift, 1/N*np.sum(xL * x))\n#lags = np.arange(-N + 1, N)                  # Create a lag axis,\n#plt.plot(lags, ac_xx_by_hand_circ_shift, '.');\n\n#plt.xlim([-100, -10])\n#np.size(ac_xx_by_hand_circ_shift)\nplt.xlabel('Lag [s]')\nplt.ylabel('Autocovariance');\n\n\n\n\n\n\n\n\n\n\nCompute the spectrum.\n\nXf = np.fft.fft(x - x.mean())           # Compute Fourier transform of x\n\n# Compute the spectrum\nSxx = 2 * dt ** 2 / T * (Xf * Xf.conj())  # Compute spectrum\nSxx = Sxx.real\n\n# Define a frequency axis.\nf = np.fft.fftfreq(N, dt)\n\n# Plot the result.\nplt.plot(f, Sxx);"
  },
  {
    "objectID": "SHO_Lab.html",
    "href": "SHO_Lab.html",
    "title": "Damped harmonic oscillator example",
    "section": "",
    "text": "# Load necessary packages\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "SHO_Lab.html#define-a-damped-harmonic-oscillator-noise",
    "href": "SHO_Lab.html#define-a-damped-harmonic-oscillator-noise",
    "title": "Damped harmonic oscillator example",
    "section": "Define a damped harmonic oscillator + noise",
    "text": "Define a damped harmonic oscillator + noise\n\ndef damped_harmonic_oscillator(omega,beta,noise,T0):\n\n    dt = 0.01;\n    T  = int(np.ceil(T0/dt))\n\n    t = np.arange(0,T)*dt\n    F = np.zeros([T,1])         # Set up forcing,\n    F[int(0.25*T)] = 1;         # ... give it a kick 25% of way into simulation.\n    x = np.zeros([T,1])\n    y = np.zeros([T,1])\n\n    x[0]=0\n    y[0]=0\n    \n    for i in range(0,T-1):\n        x[i+1] = x[i] + dt*(y[i]);\n        y[i+1] = y[i] + dt*(-omega**2*x[i] - 2*beta*y[i] + F[i] + noise*np.random.randn());\n\n    return x,t"
  },
  {
    "objectID": "SHO_Lab.html#simulate-the-model",
    "href": "SHO_Lab.html#simulate-the-model",
    "title": "Damped harmonic oscillator example",
    "section": "Simulate the model",
    "text": "Simulate the model\n\nf     = 1;\nomega = 2*np.pi*f;\nbeta  = 1;\nnoise = 0;\nT0    = 10\nx,t   = damped_harmonic_oscillator(omega,beta,noise,T0);\nplt.plot(t,x);"
  },
  {
    "objectID": "Gamma_Lab.html",
    "href": "Gamma_Lab.html",
    "title": "Gamma rhythms models",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np"
  },
  {
    "objectID": "Gamma_Lab.html#begin-with-the-inhibitory-synapse-turned-off.",
    "href": "Gamma_Lab.html#begin-with-the-inhibitory-synapse-turned-off.",
    "title": "Gamma rhythms models",
    "section": "Begin with the inhibitory synapse turned off.",
    "text": "Begin with the inhibitory synapse turned off.\n\nI0   = 30;    #Set the input drive to excite the cell.\ngI   = 0;     #Turn off inhibitory synapse, to start.\ntauI = 10;    #Set decay time of inhibitory synapse to 10ms.\nT0   = 100;   #Simulate for 100 ms.\n\n[V,s,t] = ing(I0,gI,tauI,T0)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');"
  },
  {
    "objectID": "Gamma_Lab.html#turn-on-the-inhibitory-synapse.",
    "href": "Gamma_Lab.html#turn-on-the-inhibitory-synapse.",
    "title": "Gamma rhythms models",
    "section": "Turn on the inhibitory synapse.",
    "text": "Turn on the inhibitory synapse.\n\ngI = 'SOMETHING'\n[V,s,t] = ing(I0,gI,tauI,T0);\nplt.subplot(2,1,1)\nplt.plot(t,V); plt.xlabel('Time [ms]'); plt.ylabel('Voltage [mV]');\nplt.subplot(2,1,2)\nplt.plot(t,s,'r'); plt.xlabel('Time [ms]'); plt.ylabel('Inhibitory synaptic gate');\n\nQ: How does the spiking frequency change?\nQ: How do the synapses evolve?\nQ: This model captures 3 experimental observations we discussed in class. To generate gamma, 1) The cell needs sufficient excitatory drive, 2) The GABA synapse is critical, and 3) Altering the decay time of the inhibitory synapse changes the gamma frequency.\nShow that all three observations are captured by this model."
  },
  {
    "objectID": "Regression.html",
    "href": "Regression.html",
    "title": "Regression",
    "section": "",
    "text": "In this notebook, we’ll implement an example application of linear regression applied to behavioral and electrophysiologicial data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nLoad the data\nThe example behavioral and electrophysiologicial data is regression_example_data.csv. Get these data, and load them:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nVisualize the data\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nCorrelation\nCompute the correlation between \\(x\\) and \\(y\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nRegression (compute it)\nModel the data using regression.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nRegression (plot it)\nPlot the estimated regression model with the data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nRegression example (Part 2)\nWe learn that an additional predictor - age - impacts task performance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nVisualize the new data\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nCorrelation (between task performance and age)\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nVisualize all data\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nRegression (compute it with all data)\nModel all data using regression.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nRegression (plot it with all data)\nPlot the estimated regression model with two predictors and all data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_1.html",
    "href": "Analyzing_Rhythms_Lab_1.html",
    "title": "Analyzing Rhythms Part 1",
    "section": "",
    "text": "Load modules we’ll need.\n\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\nLoad the data.\n\ndata = loadmat('Data/EEG-1.mat')    # Load the EEG data\n# Data available here\n# https://github.com/Mark-Kramer/BU-MA665-MA666/tree/master/Data\n#\nEEG  = data['EEG'].reshape(-1) # Extract the EEG variable\nt    = data['t'][0]            # ... and the t variablea\n\nLook at it.\n\nplt.plot(t,EEG)\nplt.xlabel('Time [s]')\nplt.ylabel('EEG');"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_1.html#load-the-data-and-look-at-it.",
    "href": "Analyzing_Rhythms_Lab_1.html#load-the-data-and-look-at-it.",
    "title": "Analyzing Rhythms Part 1",
    "section": "",
    "text": "Load modules we’ll need.\n\nfrom scipy.io import loadmat\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.signal import spectrogram\n\nLoad the data.\n\ndata = loadmat('Data/EEG-1.mat')    # Load the EEG data\n# Data available here\n# https://github.com/Mark-Kramer/BU-MA665-MA666/tree/master/Data\n#\nEEG  = data['EEG'].reshape(-1) # Extract the EEG variable\nt    = data['t'][0]            # ... and the t variablea\n\nLook at it.\n\nplt.plot(t,EEG)\nplt.xlabel('Time [s]')\nplt.ylabel('EEG');"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_1.html#preliminaries",
    "href": "Analyzing_Rhythms_Lab_1.html#preliminaries",
    "title": "Analyzing Rhythms Part 1",
    "section": "Preliminaries",
    "text": "Preliminaries\nQ: What is the sampling interval (dt)?\n\ndt = \"SOMETHING\"\nprint(dt)\n\nQ. What is the sampling frequency (f0)?\n\nf0 = \"SOMETHING\"\nprint(f0)\n\nQ. What is the number of points in the data (N)?\n\nN = \"SOMETHING\"\nprint(N)\n\nQ. What is the total time of the observation (T)?\n\nT = \"SOMETHING\"\nprint(T)"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_1.html#compute-the-spectrum-by-hand",
    "href": "Analyzing_Rhythms_Lab_1.html#compute-the-spectrum-by-hand",
    "title": "Analyzing Rhythms Part 1",
    "section": "Compute the spectrum “by hand”",
    "text": "Compute the spectrum “by hand”\n\n# Q. What is the Nyquist frequency and frequency resolution?\nfNQ = \"SOMETHING\"\ndf  = \"SOMETHING\"\n\n# Q. What is the frequency axis?\nfj  = np.arange(0,fNQ,df)\n\n# Then, compute the Fourier transform \"by hand\".\nx = EEG\nX = np.ndarray(np.size(fj), complex);\nfor j in range( np.size(fj) ):\n    X[j] = \"SOMETHING\"\n\n# And the spectrum,\nSxx = \"SOMETHING\"\n\n# Plot it,\nplot(fj, Sxx.real)\nplt.xlim([0, 100])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]');"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_1.html#compute-the-power-spectrum-using-the-fft-function.",
    "href": "Analyzing_Rhythms_Lab_1.html#compute-the-power-spectrum-using-the-fft-function.",
    "title": "Analyzing Rhythms Part 1",
    "section": "Compute the power spectrum using the FFT function.",
    "text": "Compute the power spectrum using the FFT function.\n\nx   = EEG\nX   = np.fft.fft(x)                        # Compute Fourier transform of x\nSxx = \"SOMETHING\"                          # Compute spectrum\nSxx = Sxx[0:int(N / 2)].real               # Ignore negative frequencies\n\nDefine the frequency axis\n\ndf  = \"SOMETHING\"                  # Determine frequency resolution\nfNQ = \"SOMETHING\"                  # Determine Nyquist frequency\nfaxis = np.arange(0,fNQ,df)        # Construct frequency axis\n\nPlot the spectrum versus frequency\nQ. What do you see?\n\nplt.plot(faxis, Sxx)\nplt.xlim([0, 100])                          # Select frequency range\nplt.xlabel('Frequency [Hz]')                # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]');\n\nPlot the spectrum versus frequency on a decibel scale.\nQ. Now what do you see?\n\nplt.figure()\nplt.plot(faxis, [???])   # Plot the spectrum in decibels.\nplt.xlim([0, 100])                               # Select the frequency range.\nplt.ylim([-60, 0])                               # Select the decibel range.\nplt.xlabel('Frequency [Hz]')                     # Label the axes.\nplt.ylabel('Power [dB]');\n\nPlot the spectrum versus frequency on a logarithmic frequency axis.\nQ. And now what do you see?\n\nplt.figure()\nplt.[???]                                            # Log-log scale\nplt.xlim([df, 100])                                  # Select frequency range\nplt.ylim([-60, 0])                                   # ... and the decibel range.\nplt.xlabel('Frequency [Hz]')                         # Label the axes.\nplt.ylabel('Power [dB]');"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_1.html#apply-hanning-taper",
    "href": "Analyzing_Rhythms_Lab_1.html#apply-hanning-taper",
    "title": "Analyzing Rhythms Part 1",
    "section": "Apply Hanning taper",
    "text": "Apply Hanning taper\nApply the Hanning taper to the data.\n\nx_tapered  = ???\nplt.figure()\nplt.plot(t,x)\nplt.plot(t,x_tapered);\n\nApply the Hanning taper and look at the spectrum.\n\nxf_tapered  = \"SOMETHING\"                        # Compute Fourier transform of x.\nSxx_tapered = \"SOMETHING\"                        # Compute the spectrum,\nSxx_tapered = np.real(Sxx_tapered[:int(N / 2)])  # ... and ignore negative frequencies.\n\nplt.figure()\nplt.semilogx(faxis,10*np.log10(Sxx))         # Plot spectrum of untapered signal.  \nplt.semilogx(faxis,10*np.log10(Sxx_tapered)) # Plot spectrum vs tapered signal.\nplt.xlim([faxis[1], 100])                    # Select frequency range,\nplt.ylim([-70, 20])                          # ... and the power range.\nplt.xlabel('Frequency [Hz]')                 # Label the axes\nplt.ylabel('Power [$\\mu V^2$/Hz]')"
  },
  {
    "objectID": "Analyzing_Rhythms_Lab_1.html#spectrogram",
    "href": "Analyzing_Rhythms_Lab_1.html#spectrogram",
    "title": "Analyzing Rhythms Part 1",
    "section": "Spectrogram",
    "text": "Spectrogram\n\n# Plot the spectrogram.\n\nFs = 1 / dt               # Define the sampling frequency,\ninterval = int(Fs)        # ... the interval size,\noverlap = int(Fs * 0.95)  # ... and the overlap intervals\n\n                          # Compute the spectrogram\nf0, t0, Sxx0 = spectrogram(\n    EEG,                  # Provide the signal,\n    fs=Fs,                # ... the sampling frequency,\n    nperseg=interval,     # ... the length of a segment,\n    noverlap=overlap)     # ... the number of samples to overlap,\nplt.pcolormesh(t0, f0, 10 * np.log10(Sxx0),\n               cmap='jet')# Plot the result\nplt.colorbar()            # ... with a color bar,\nplt.ylim([0, 70])             # ... set the frequency range,\nplt.xlabel('Time [s]')       # ... and label the axes\nplt.ylabel('Frequency [Hz]');"
  },
  {
    "objectID": "Rhythms_1.html",
    "href": "Rhythms_1.html",
    "title": "Rhythms",
    "section": "",
    "text": "In this notebook we will simulate rhythmic activity as a first step in our understanding of brain rhythms.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nMaking sinusoids\nIt’s relatively easy to make sinusoids in Python, using built-in commands. There are many ways to do so, and we’ll start here by constructing a time axis. Consider the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: The variable t defines a time axis. When does time start? When does time end? What is the sampling interval (i.e., the time between samples)?\n\n\n\nNow, let’s define a new variable that represents a sinusoid,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Is x a sinusoid? What is the frequency of the oscillation?\n\n\n\n\n\n\n\n\n\nQ: How would you update x to create a sine function that oscillates at 10 Hz?\n\n\n\n\n\n\n\n\n\nQ: How would you create a cosine function that oscillates at 14 Hz?\n\n\n\n\n\nOrthogonality of sinusoids\nAn important feature of sinusoids is orthogonality.\nBriefly, if we multiply together two cosine functions, and sum the resulting product, we get zero unless the frequencies match.\nLet’s illustrate this idea in Python. To do so, first define two sinusoids,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What is the frequency of each sinusoid? Plot these sinusoids to see how they behave.\n\n\n\nTo check orthogonality, we want to multiply together these two cosine functions, point-by-point at each time, then sum their product over all time.\n\n\n\n\n\n\nQ: How do we perform this operation in Python? Do so, and report what you find.\n\n\n\n\n\n\n\n\n\nQ: How does this result change for different choices of f1 and f2?\n\n\n\n\n\n\n\n\n\nQ: How does this result change if you use sine?\n\n\n\n\n\nDecomposing a sinusoid into one component\nWe’ll now consider a more complicated signal. Please download the data Rhythms_1.csv and load the data,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What are the dimensions of each variable? What is the sampling interval? What is the total duration of the data?\n\n\n\n\n\n\n\n\n\nQ: By visual inspection of the data, what frequencies dominate the signal?\n\n\n\nNow, we’d like to compare sinusoids with known frequency to the data.\nIn doing so, our goal is to identify those sinusoids that “best match” the data; this will reveal the rhythms that appear in the signal, which we will ultimately display graphically in a power spectrum.\nTo begin this process, we’ll specify a handful of frequencies to consider.\nLet’s start with a sine function oscillating at 1 Hz.\n\n\n\n\n\n\nQ: Define a 1 Hz sine function that lasts for the duration of the data, and has the same sampling interval (i.e., the same time axis as the data).\n\n\n\nWith the sine function now defined, let’s “compare” it to the data\nTo do so, we multiply point-by-point the data and sine function and sum the result.\nBecause we’re approximating an integral, we’ll need to include the differential (dt) in the sum.\n\n\n\n\n\n\nQ: How do we compute this integral?\n\n\n\n\n\n\n\n\n\nQ: Consider your result for this integral. Does the 1 Hz sine function make a significant contribution to the data? Is the result of this integral consistent with your visual inspection of the data?\n\n\n\n\n\nDecomposing a sinusoid into many components\nNow, we’ve compared a single sinusoid - the 1 Hz sine function - to the data.\nIn this case, we’ve found that the corresponding integral is small.\nHowever, we’re not interested in only this sinusoid; we’d really like to consider a range of sinusoids (both sine and cosine functions) oscillating at different frequencies.\nOur goal in this part of notebook is to do so, and compare the data to sinusoids at different frequencies.\n\n\n\n\n\n\nQ: Compare the data to sinusoids at integer frequencies {1,2,3, …, 10} Hz. Save your results for each frequency of the cosine function in a variable called “A”, and the results for each frequency of the sine function in a variable called “B”.\nHINT: There are many ways to compute these comparisons. You might perform each computation “by hand” (e.g., compute A at 1 Hz, B at 1 Hz, A at 2 Hz, B at 2 Hz, . . . ). In doing so, you’ll notice a lot of repetition. Is there a more efficient way to perform so many similar computations?"
  },
  {
    "objectID": "Backpropagation.html",
    "href": "Backpropagation.html",
    "title": "Backpropagation",
    "section": "",
    "text": "In this notebook, we’ll implement a quick representation of the backpropagation algorithm for the simple two node network.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nSteps to backpropagation\nWe outlined 4 steps to perform backpropagation,\n\nChoose random initial weights.\nTrain the neural network on given input and output data.\nUpdate the weights.\nRepeat steps 2 & 3 many times.\n\nLet’s now implement these steps in an example data set.\n\n\nLoad example data\nThe training data is backpropagation_example_data.csv. Get these data, and load them:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nHere we acquire two variables:\nin_true: the true input to the hidden two-node neural network\nout_true: the true output of the hidden two-node neural network\nThe two-node neural network is hidden because we don’t know the weights (w[0] and w[1]).\nInstead, we only observe the pairs of inputs and outputs to this hidden neural network.\nLet’s look at some of these data:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThese data were created by sending the inputs (in_true, the first column above) into a two-node neural network to produce the outputs (out_true, the second column above).\nAgain, we do not know the weights of this network … that’s what we’d like to find.\nTo do so, we’ll use these data to train a neural network through back propagation.\n\n\nFor training, first define two useful functions:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nNow, train the neural network with these (in_true, out_true) data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nChallenges\n\nUse the chain rule to verify the expression for \\(\\dfrac{dC}{dw_0} = (out-target)s_2(1-s_2) w_1 s_1 (1-s_1) s_0\\).\nComplete the code above to determine the weights (w[0] and w[1]) of the hidden two-node neural network."
  },
  {
    "objectID": "HH.html",
    "href": "HH.html",
    "title": "Hodgkin-Huxley Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the Hodgkin-Huxley (HH) neuron model. This model is arguably the most important computational model in neuroscience. We’ll focus here on simulating this model and understanding its pieces.\n\n1 Preliminaries\nBefore beginning, let’s load in the Python packages we’ll need:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn addition, let’s import the functions we’ll need to simulate the HH model, which are available on this repository:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2 The Hodgkin-Huxley (HH) equation code.\nTo start, let’s examine the code for the HH model. To do so, visit the raw code avaiable here.\n\n\n\n\n\n\nQ: Examine this code. Can you make sense of it? Can you identify the gating variables? The rate functions? The equations that define the dynamics? We’ll answer these questions in this in notebook, but try so on your own first.\n\n\n\nWhenever examining code, it’s useful to consider the inputs to the code, and the outputs produced by the code. There are two inputs to HH0:\n\nI0 = the current we inject to the neuron.\nT0 = the total time of the simulation in [ms].\n\nAnd there are five outputs:\n\nV = the voltage of neuron.\nm = activation variable for Na-current.\nh = inactivation variable for Na-current.\nn = activation variable for K-current.\nt = the time axis of the simulation (useful for plotting).\n\n\n\n3 At low input current (I0), examine the HH dynamics.\nTo understand how the HH model works, we’ll start by focusing on the case when I0 is small. Let’s fix the input current to zero,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nand let’s simulate the model for 100 ms,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’ve now defined both inputs to the HH function, and can execute it, as follows,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that the function returns five outputs, which we assign to the variables V, m, h, n, and t.\n\n\n\n\n\n\nQ: What are the dynamics of the voltage (variable V) resulting from this simulation? HINT: Plot V vs t.\n\n\n\n\n\n\n\n\n\nQ: What are the dynamics of the gating variables (m, h, n) resulting from this simulation? HINT: Plot them!\n\n\n\n\n\n\n\n\n\nQ: What are the final values (after the 100 ms of simulation) of V, m, h, and n?\n\n\n\n\n\n4 At high input current (I0), examine the HH dynamics of a spike.\nLet’s now increase the input current to the HH model and get this model to generate repeated spiking activity. To do so, let’s set,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can now simulate this model,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What happens to the dynamics? HINT: Plot V vs t.\n\n\n\nObservations: You should have found that, at this value of input current, the model generates repeated spikes.\n\nLet’s now explore how the combined gates and dynamics evolve. To do so, let’s start by focusing our plot on a single spike. As a first step, let’s plot the voltage, and choose the time axis to focus on a single spike,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’ve now plotted the voltage dynamics for a single spike (and colored the curve black).\nLet’s now plot the three gating variables. To do so, we’ll make another plot.\nLet’s start by displaying the gating variable m over the same x-limits,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that, in the call to plot we included the input label. This will be useful when we create a legend. Within this subplot, we can also simultaneously show the gating variables h and n, with the x-axis labeled.\nLet’s also add a legend to help us keep track of the different curves:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Using the figure you created above, describe how the gates swing open and closed during a spike.\n\n\n\nASIDE: Here’s a nice plotting trick, to link the x-axes of our two subfigures. Linking the axes is useful so that, when we zoom or move one subfigure, the other subfigure will match the x-axis.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, in the figure, you may use the pan/zoom tool to adjust the linked subplots.\n\n\n5 At high input current (I0), describe the dynamics of the conductances.\nWe have so far explored how the three gates m, h, and n evolve during a spike. By combining these terms, we can visualize how the conductances evolve during a spike. To do so, let’s stick with the simulation results we generated in the previous section, and focus our plot on a single spike,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, to plot the conductances, let’s define three new variables,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Where do these terms come from?\n\n\n\nThen, let’s plot these conductances,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\nAt high input current (I0), describe the dynamics of the currents. In the previous section, we explored how the three conductances (gNa, gK, gL) evolve during a spike.\nLet’s now visualize how the ionic currents evolve during a spike.\nTo do so, let’s stick with the same settings used in the previous section and examine the same simulation result. Again, we’ll focus our plot on a single spike.\nNow, to plot the current, let’s define the new variables,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\n\n\n\n\n\n\nQ: You may notice a small, transient decrease in the sodium current INa near 47 ms. What causes this?\n\n\n\n\n\n6 Discussion\n\nHow is the HH model different from / similar to the IF and LIF models?\nWhat are the ion species simulated in the HH model?\nWhich ion species is fastest / slowest?\nHow many variables are in the HH model? Define each.\nSketch the model equations, in schematic form, to capture the “essence” of the behavior (don’t worry about the detailed values for parameters).\nWhich gating variables are depolarization activated / depolarization inactivated?\nSketch the steady-state curves for the gating variables.\nConsider the current: I_K=g_K n^4  (E_K-V)\n\nDefine each term.\nHow does this current behave for different values of V?\n\nConsider the current: I_Na=g_Na m^3 h (E_Na-V)\n\nDefine each term.\nHow does this current behave for different values of V?\n\n\n\n\n7 Challenges\n\nDescribe the dynamics during an action potential in the HH model. How does the voltage change? How do the gates open and close? How do the ions flow?\nDetermine how the firing rate of the HH model varies with input current I. Plot the firing rate versus I (i.e., plot the “f-I curve”).\nHow does the firing rate of the HH model change as you increase the potassium conductance? Provide a “simulation” explanation and a “physical” explanation.\nHow does the firing rate of the HH model change as you increase sodium conductance? Provide a “simulation” explanation and a “physical” explanation.\nBONUS: Use the forward and backward rate functions (\\(\\alpha\\) and \\(\\beta\\)) in the HH model (see code) to plot the steady state function and time constant for each channel (\\(m\\), \\(h\\), \\(n\\)) versus voltage. In other words, create Figure 1 in the Hodgkin-Huxley Cheat Sheet."
  }
]