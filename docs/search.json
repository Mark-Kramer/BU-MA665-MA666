[
  {
    "objectID": "IF.html",
    "href": "IF.html",
    "title": "BU MA665 MA666",
    "section": "",
    "text": "format: html: code-fold: true code-tools: true jupyter: python 3 number-sections: true\nIn this notebook we will use Python to simulate the integrate and fire (I&F) neuron model. We’ll investigate, in particular, how the spiking activity varies as we adjust the input current \\(I\\)."
  },
  {
    "objectID": "IF.html#preliminaries",
    "href": "IF.html#preliminaries",
    "title": "BU MA665 MA666",
    "section": "Preliminaries",
    "text": "Preliminaries\nBefore beginning, let’s load in the Python package we’ll need:\n\nimport numpy as np\nimport matplotlib.pyplot as plt"
  },
  {
    "objectID": "IF.html#numerical-solutions---introduction",
    "href": "IF.html#numerical-solutions---introduction",
    "title": "BU MA665 MA666",
    "section": "Numerical solutions - Introduction",
    "text": "Numerical solutions - Introduction\nHow do we compute a numerical solution to the integrate and fire model? The basic idea is to rearrange the differential equation to get \\(V(t+1)\\) on the left hand side, and \\(V(t)\\) on the right hand side. Then, if we know what’s happening at time \\(t\\), we can solve for what’s happening at time \\(t+1\\).\nFor example, consider the differential equation:\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{I}{C}\n\\]\nIn words, we can think of:\n\\(dV\\) as the “change in voltage V”,\n\\(dt\\) as the “change in time t”.\nLet’s consider the case that we record the voltage \\(V\\) in discrete time steps. So we observe:\n\\(V[0], V[1], V[2], \\ldots\\)\nat times:\n\\(dt, \\, 2*dt, \\, 3*dt, \\ldots\\)\nwhere \\(dt\\) is the time between our samples of \\(V\\).\nWe can now write the “change in voltage V” as:\n\\[\n  dV = V(t+1) - V(t)\n\\]\nNotice that the change in voltage is the difference in V between two sequential time samples. Now, let’s rewrite \\(\\dfrac{dV}{dt}\\) as,\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt }\n\\]\nwhere we’ve replaced \\(dV\\). Now, let’s substitute this expression into the equation at the top of this file:\n\\[\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n\\]\nSolving this equation for \\(V(t+1)\\) you’ll find that:\n\\[\n  V(t+1) = V(t) + dt*(I/C)\n\\]\nNotice that, in this expression, we use our current value of the voltage V(t) and the model (I/C) to determine the next value of the voltage V(t+1).\nNow, let’s program this equation in Python. First, let’s set the values for the parameters \\(I\\) and \\(C\\).\n\nC=1.0\nI=1.0\n\nWe also need to set the value for \\(dt\\). This defines the time step for our model. We must choose it small enough so that we don’t miss anything interesting. We’ll choose:\n\ndt=0.01\n\nLet’s assume the units of time are seconds. So, we step forward in time by \\(0.01\\) s.\nThe right hand side of our equation is nearly defined, but we’re still missing one thing, \\(V(t)\\).\n\n\n\n\n\n\nQ: What value do we assign to \\(V(t)\\)?\n\n\n\nSo here’s an easier question: what initial value do we assign to \\(V(t)\\)?\nTo start, we’ll create an array of zeros to hold our results for \\(V\\):\n\nV = np.zeros([1000,1])\nV.shape\n\n(1000, 1)\n\n\nThis array V consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of V (i.e., step forward in time), in a way consistent with our model.\nLet’s choose an initial value for V of 0.2, which in our simple model we’ll assume represents the rest state.\n\nV[0]=0.2\n\n\n\n\n\n\n\nQ: Given the initial state V[0]=0.2, calculate V[1]. Then calcualte V[2].\n\n\n\nAfter the two calculations above, we’ve moved forward two time steps into the future, from \\(t=0\\) s to \\(t=0.01\\) s, and then from \\(t=0.01\\) s to \\(t=0.02\\) s. But what if we want to know \\(V\\) at \\(t=10\\) s? Then, this iteration-by-hand procedure becomes much too boring and error-prone. So, what do we do? Let’s make the computer do it …"
  },
  {
    "objectID": "IF.html#numerical-solutions---implementation",
    "href": "IF.html#numerical-solutions---implementation",
    "title": "BU MA665 MA666",
    "section": "Numerical solutions - Implementation",
    "text": "Numerical solutions - Implementation\nLet’s computerize this iteration-by-hand procedure to find V[999].\nTo do so, we’ll use a for-loop.\nHere’s what it looks like:\n\nfor k in range(1,999):\n    V[k+1] = V[k] + dt*(I/C)\n\n\n\n\n\n\n\nQ: Does this loop make sense? Describe what’s happening here.\n\n\n\n\n\n\n\n\n\nQ: Why does the range command end at 999?\n\n\n\nExecute this for-loop and examine the results in vector V. To do so, let’s plot V:\n\n# plt.plot(V);\n\n\n\n\n\n\n\nQ: What happens to the voltage after 1000 steps?\n\n\n\nThis plot is informative, but not great. Really, we’d like to plot the voltage as a function of time, not steps or indices. To do so, we need to define a time axis:\n\nt = np.arange(0,len(V))*dt\n\n\n\n\n\n\n\nQ: What’s happening in the command above? Does it make sense? (If not, trying printing or plotting t.)\n\n\n\nNow, with time defined, let’s redo the plot of the voltage with the axes labeled appropriately.\n\n# plt.plot(t,V)\n# plt.xlabel('Time [s]');\n# plt.ylabel('V');\n\nFinally, let’s put it all together . . ."
  },
  {
    "objectID": "IF.html#if-code-version-1",
    "href": "IF.html#if-code-version-1",
    "title": "BU MA665 MA666",
    "section": "I&F CODE (version 1)",
    "text": "I&F CODE (version 1)\nSo far, we constructed parts of the I&F model in bits-and-pieces. Let’s now collect all the code, compute a numerical solution to the I&F model, and plot the results (with appropriate axes).\nFirst, let’s clear all the variables:\n\n%reset\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nI   = 1                           #Set the parameter I.\nC   = 1                           #Set the parameter C.\ndt  = 0.01                        #Set the timestep.\nV   = np.zeros([1000,1])             #Initialize V.\nV[0]= 0.2;                        #Set the initial value of V.\n\nfor k in range(1,999):            #March forward in time,\n    V[k+1] = V[k] + dt*(I/C)      #... updating V along the way.\n\nt = np.arange(0,len(V))*dt        #Define the time axis.\n\n#plt.plot(t,V)                         #Plot the results.\n#plt.xlabel('Time [s]')\n#plt.ylabel('Voltage [mV]');\n\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=0? Can you set I so that V &gt; 20 within 10 s?"
  },
  {
    "objectID": "IF.html#voltage-threshold",
    "href": "IF.html#voltage-threshold",
    "title": "BU MA665 MA666",
    "section": "Voltage threshold",
    "text": "Voltage threshold\nNotice, our model is missing something important: the reset.\n\n\n\n\n\n\nQ: Without the reset, how does the voltage behave as \\(t\\rightarrow\\infty\\) (if \\(I&gt;0\\))?\n\n\n\nNow, let’s update our model to include the reset. To do so, we’ll add two things to our code.\n\nFirst, we’ll define the voltage threshold Vth, and reset voltage Vreset.\nSecond, we’ll check to see if V exceeds Vth using an if-statement; if it does, then we’ll set V equal to Vreset.\n\n\n\n\n\n\n\nQ: How will you update the code below to include the reset?\n\n\n\n\nVth = 1;        #Define the voltage threshold.\nVreset = 0;     #Define the reset voltage.\n\nfor k in range(1,999):            #March forward in time,\n    V[k+1] = V[k] + dt*(I/C)      #Update the voltage,\n    ### ADD SOMETHING HERE??? --------------------------"
  },
  {
    "objectID": "IF.html#if-code-version-2",
    "href": "IF.html#if-code-version-2",
    "title": "BU MA665 MA666",
    "section": "I&F CODE (version 2)",
    "text": "I&F CODE (version 2)\nNow, let’s put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\n%reset\n\nOnce deleted, variables cannot be recovered. Proceed (y/[n])?  y\n\n\n\n### ADD YOUR CODE!\n\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=10? If I=100?\n\n\n\n\n\n\n\n\n\nQ: Adjust the parameter C. What happens to V if C=0.1? If C=10?\n\n\n\n\n\n\n\n\n\nQ: What is “spiking” in this I&F model?"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BU MA665 MA666",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]