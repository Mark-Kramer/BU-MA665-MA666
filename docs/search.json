[
  {
    "objectID": "IF.html",
    "href": "IF.html",
    "title": "Integrate and Fire Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the integrate and fire (I&F) neuron model. We’ll investigate, in particular, how the spiking activity varies as we adjust the input current \\(I\\).\n\n1 Preliminaries\nBefore beginning, let’s load in the Python package we’ll need:\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n\n2 Numerical solutions - Introduction\nHow do we compute a numerical solution to the integrate and fire model? The basic idea is to rearrange the differential equation to get \\(V(t+1)\\) on the left hand side, and \\(V(t)\\) on the right hand side. Then, if we know what’s happening at time \\(t\\), we can solve for what’s happening at time \\(t+1\\).\nFor example, consider the differential equation:\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{I}{C}\n\\]\nIn words, we can think of:\n\\(dV\\) as the “change in voltage V”,\n\\(dt\\) as the “change in time t”.\nLet’s consider the case that we record the voltage \\(V\\) in discrete time steps. So we observe:\n\\(V[0], V[1], V[2], \\ldots\\)\nat times:\n\\(dt, \\, 2*dt, \\, 3*dt, \\ldots\\)\nwhere \\(dt\\) is the time between our samples of \\(V\\).\nWe can now write the “change in voltage V” as:\n\\[\n  dV = V(t+1) - V(t)\n\\]\nNotice that the change in voltage is the difference in V between two sequential time samples. Now, let’s rewrite \\(\\dfrac{dV}{dt}\\) as,\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt }\n\\]\nwhere we’ve replaced \\(dV\\). Now, let’s substitute this expression into the equation at the top of this file:\n\\[\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n\\]\nSolving this equation for \\(V(t+1)\\) you’ll find that:\n\\[\n  V(t+1) = V(t) + dt*(I/C)\n\\]\nNotice that, in this expression, we use our current value of the voltage V(t) and the model (I/C) to determine the next value of the voltage V(t+1).\nNow, let’s program this equation in Python. First, let’s set the values for the parameters \\(I\\) and \\(C\\).\n\n\nCode\nC=1.0\nI=1.0\n\n\nWe also need to set the value for \\(dt\\). This defines the time step for our model. We must choose it small enough so that we don’t miss anything interesting. We’ll choose:\n\n\nCode\ndt=0.01\n\n\nLet’s assume the units of time are seconds. So, we step forward in time by \\(0.01\\) s.\nThe right hand side of our equation is nearly defined, but we’re still missing one thing, \\(V(t)\\).\n\n\n\n\n\n\nQ: What value do we assign to \\(V(t)\\)?\n\n\n\nSo here’s an easier question: what initial value do we assign to \\(V(t)\\)?\nTo start, we’ll create an array of zeros to hold our results for \\(V\\):\n\n\nCode\nV = np.zeros([1000,1])\nV.shape\n\n\n(1000, 1)\n\n\nThis array V consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of V (i.e., step forward in time), in a way consistent with our model.\nLet’s choose an initial value for V of 0.2, which in our simple model we’ll assume represents the rest state.\n\n\nCode\nV[0]=0.2\n\n\n\n\n\n\n\n\nQ: Given the initial state V[0]=0.2, calculate V[1]. Then calcualte V[2].\n\n\n\nAfter the two calculations above, we’ve moved forward two time steps into the future, from \\(t=0\\) s to \\(t=0.01\\) s, and then from \\(t=0.01\\) s to \\(t=0.02\\) s. But what if we want to know \\(V\\) at \\(t=10\\) s? Then, this iteration-by-hand procedure becomes much too boring and error-prone. So, what do we do? Let’s make the computer do it …\n\n\n3 Numerical solutions - Implementation\nLet’s computerize this iteration-by-hand procedure to find V[999].\nTo do so, we’ll use a for-loop.\nHere’s what it looks like:\n\n\nCode\nfor k in range(1,999):\n    V[k+1] = V[k] + dt*(I/C)\n\n\n\n\n\n\n\n\nQ: Does this loop make sense? Describe what’s happening here.\n\n\n\n\n\n\n\n\n\nQ: Why does the range command end at 999?\n\n\n\nExecute this for-loop and examine the results in vector V. To do so, let’s plot V:\n\n\nCode\n# plt.plot(V);\n\n\n\n\n\n\n\n\nQ: What happens to the voltage after 1000 steps?\n\n\n\nThis plot is informative, but not great. Really, we’d like to plot the voltage as a function of time, not steps or indices. To do so, we need to define a time axis:\n\n\nCode\nt = np.arange(0,len(V))*dt\n\n\n\n\n\n\n\n\nQ: What’s happening in the command above? Does it make sense? (If not, trying printing or plotting t.)\n\n\n\nNow, with time defined, let’s redo the plot of the voltage with the axes labeled appropriately.\n\n\nCode\n# plt.plot(t,V)\n# plt.xlabel('Time [s]');\n# plt.ylabel('V');\n\n\nFinally, let’s put it all together . . .\n\n\n4 I&F CODE (version 1)\nSo far, we constructed parts of the I&F model in bits-and-pieces. Let’s now collect all the code, compute a numerical solution to the I&F model, and plot the results (with appropriate axes).\nFirst, let’s clear all the variables:\n\n\nCode\n%reset\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nI   = 1                           #Set the parameter I.\nC   = 1                           #Set the parameter C.\ndt  = 0.01                        #Set the timestep.\nV   = np.zeros([1000,1])             #Initialize V.\nV[0]= 0.2;                        #Set the initial value of V.\n\nfor k in range(1,999):            #March forward in time,\n    V[k+1] = V[k] + dt*(I/C)      #... updating V along the way.\n\nt = np.arange(0,len(V))*dt        #Define the time axis.\n\n#plt.plot(t,V)                         #Plot the results.\n#plt.xlabel('Time [s]')\n#plt.ylabel('Voltage [mV]');\n\n\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=0? Can you set I so that V &gt; 20 within 10 s?\n\n\n\n\n\n5 Voltage threshold\nNotice, our model is missing something important: the reset.\n\n\n\n\n\n\nQ: Without the reset, how does the voltage behave as \\(t\\rightarrow\\infty\\) (if \\(I&gt;0\\))?\n\n\n\nNow, let’s update our model to include the reset. To do so, we’ll add two things to our code.\n\nFirst, we’ll define the voltage threshold Vth, and reset voltage Vreset.\nSecond, we’ll check to see if V exceeds Vth using an if-statement; if it does, then we’ll set V equal to Vreset.\n\n\n\n\n\n\n\nQ: How will you update the code below to include the reset?\n\n\n\n\n\nCode\nVth = 1;        #Define the voltage threshold.\nVreset = 0;     #Define the reset voltage.\n\nfor k in range(1,999):            #March forward in time,\n    V[k+1] = V[k] + dt*(I/C)      #Update the voltage,\n    ### ADD SOMETHING HERE??? --------------------------\n\n\n\n\n6 I&F CODE (version 2)\nNow, let’s put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\n\nCode\n%reset\n\n\nOnce deleted, variables cannot be recovered. Proceed (y/[n])?  y\n\n\n\n\nCode\n### ADD YOUR CODE!\n\n\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=10? If I=100?\n\n\n\n\n\n\n\n\n\nQ: Adjust the parameter C. What happens to V if C=0.1? If C=10?\n\n\n\n\n\n\n\n\n\nQ: What is “spiking” in this I&F model?\n\n\n\n\n\n7 Discussion\n\nDescribe the main components of the IF model. Draw it (in some way).\nDescribe the main components of the LIF model. Draw it (in some way).\nDescribe the differences and similarities between the IF and LIF models.\nThe IF model is meant to mimic a neurons activity. Describe what is realistic about the IF model? What is unrealistic?\nDescribe the roles of the IF model parameters Vreset and Vthreshold.\nConsider the IF model. Sketch voltage (V) versus time (t) for a small input current, for a large input current.\n\nHow does an increase in capacitance (C) impact the dynamics?\nCan you interpret this physically?\n\n\n\n\n8 Challenges\n\nConsider the LIF model. Plot (in Python) voltage (V) versus time (t) for a small input current, for a large input current.\nHow does an increase in the capacitance (C) impact the dynamics of the LIF model?\nHow does an increase in the resistance (R) impact the dynamics of the LIF model?\nDetermine how the firing rate of the LIF model varies with input I. Plot the firing rate versus I (i.e., plot the “f-I curve”).\nADVANCED. Simulate the Izhikevich neuron. Provide examples of two different types of spiking activity."
  },
  {
    "objectID": "Perceptron.html",
    "href": "Perceptron.html",
    "title": "Perceptron",
    "section": "",
    "text": "In this notebook, we will construct simple perceptron models. We’ll start by implementing a perceptron model, and seeing how it behaves. We’ll then outline the steps to train a perceptron to classify a point as above or below a line.\nThis discussion follows the excellent example and discussion at The Nature of Code. Please see that reference for additional details, and a more sophisticated coding strategy (using Classes in Python)."
  },
  {
    "objectID": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "href": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "title": "Perceptron",
    "section": "3.1 Provide perceptron with inputs and known answer.",
    "text": "3.1 Provide perceptron with inputs and known answer.\nFirst, let’s make a function that computes a line, and determines if a given y value is above or below the line. We’ll use this function to return the correct (“known”) answer. Having known answers is important for training the perceptron. We’ll use the known answers to tell the when it’s right or wrong (i.e., when the perceptron makes an error).\nLet’s define the function (known_answer) should take four inputs:\n\nslope\nintercept\nx\ny\n\nwhere the (x,y) value is a point we choose on the plane. The function should return one output:\n\ndesired_output\n\nwhere,\ndesired_output = 1, if the y value (the last input) is above the line,\ndesired_putput = 0, if the y value (the last input) is below the line.\nComplete the function below:\n\n\nCode\ndef known_answer(slope, intercept, x, y):\n    print(\"Do something!\")\n    #Determine yline\n    #Determine if y is above yline\n\n\n\n\n\n\n\n\nQ: Consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand the line with slope and intercept,\n\n\nslope = 2  intercept = 1\n\n\nIs the (x,y) point above or below the line?\n\n\n\nA: To answer this, let’s ask our function,\n\n\nCode\nx,y       = 0.7,3\nslope     = 2\nintercept = 1\ncorrect_answer = known_answer(slope, intercept, x, y)\nprint(correct_answer)\n\n\nA (Continued): We find a correct_answer of 1.\n\n\nSo, the point (x,y)=(0.7,3) is above the line with slope 2 and intercept 1."
  },
  {
    "objectID": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "href": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "title": "Perceptron",
    "section": "3.2 Ask perceptron to guess an answer.",
    "text": "3.2 Ask perceptron to guess an answer.\nOur next step is to compare our desired output (computed in Step 1) to the output guessed by the perceptron. To do so, we’ll need to compute the feedforward solution for the perceptron (i.e., given the inputs and bias, determine the perceptron output). Let’s do so complete the function below,\n\n\nCode\ndef feedforward(x, y, wx, wy, wb):\n    print(\"Do something!\")\n    # Fix the bias.\n    # Define the activity of the neuron, activity.\n    # Apply the binary threshold.\n\n\nThis function takes five inputs:\n\nx = the x coordinate of the point we choose in the plane.\ny = the y coordinate of the point we choose in the plane.\nwx = the weight of x input.\nwy = the weight of y input.\nwb = the weight of the bias.\n\nAnd this function returns one output:\n\nthe perceptron’s guess, is the point above (=1) or below (=0) the line.\n\n\n\n\n\n\n\nQ: Again consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand set initial values for the perceptron weights. Let’s just set these all to 0.5; our goal in the rest of this module will be to train the perceptron by adjusting these weights. But for now,\n\n\nwx,wy,wb = 0.5\n\n\nThen, ask the perceptron for it’s guess for it’s guess, is the point above or below the line?\n\n\n\n\n\n\n\nCode\nx,y      = 0.7,3\nwx,wy,wb = 3*[0.5]\nperceptron_guess = feedforward(x, y, wx, wy, wb)\nprint(perceptron_guess)\n\n\nA: We find a peceptron_guess of 1.\nSo, the perceptron guesses that the point (x,y)=(0.7,3) is above the line."
  },
  {
    "objectID": "Perceptron.html#compute-the-error.",
    "href": "Perceptron.html#compute-the-error.",
    "title": "Perceptron",
    "section": "3.3 Compute the error.",
    "text": "3.3 Compute the error.\nWe’ve now answered the question “Is the (x,y) point above the line?” in two ways:\n\nthe known answer, and\nthe perceptron’s guess.\n\nLet’s compute the error as the difference between these two answers:\n\n\nCode\nerror = 'SOMETHING?'\nprint(error)\n\n\n\n\n\n\n\n\nQ: What do you find for the error? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "href": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "title": "Perceptron",
    "section": "3.4 Adjust all weights according to the error.",
    "text": "3.4 Adjust all weights according to the error.\nTo update the weights, we’ll use the expression,\nnew weight = weight + error * input * learning constant\nWe need to compute this for each weight (wx, wy, wb).\nFirst, let’s set the learning constant,\n\n\nCode\nlearning_constant = 0.01\n\n\nThen, we can compute the new weights,\n\n\nCode\nwx = \"SOMETHING\"\nwy = \"SOMETHING\"\nwb = \"SOMETHING\"\nprint(wx)\n\n\nNotice that, in the update to wb we use the fact that the bias equals 1.\n\n\n\n\n\n\nQ: What do you find for the new weights? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#return-to-step-1-and-repeat",
    "href": "Perceptron.html#return-to-step-1-and-repeat",
    "title": "Perceptron",
    "section": "3.5 Return to Step 1 and repeat …",
    "text": "3.5 Return to Step 1 and repeat …\nWe could try to compute these repetitions by hand, for example by repeating the cells above. To do so, we’d choose a new point in the (x,y) plane, determine whether it’s above the line 2x+1, ask the perceptron to guess whether it’s above the line, then use the error to update the perceptron’s weights.\nBut we want to evaluate this procedure 2000 times. Doing so by hand would be a total pain, and highly error prone. Instead, let’s ask the computer to do the boring work of multiple repetitions. To do so, let’s collect the code above, and examine 2000 (x,y) points chosen randomly in the plane. We’ll wrap our code above inside a for-loop to make this efficient,\n\n\nCode\nslope     = 2;                      # Define the line with slope, \nintercept = 1;                      # ... and intercept.\n\nwx,wy,wb = 3*[0.5];                 # Choose initial values for the perceptron's weights\n\nlearning_constant = 0.01;           # And, set the learning constant.\n\nestimated_slope = np.zeros(2000)    # Variables to hold the perceptron estimates.\nestimated_intercept = np.zeros(2000)\n\nfor k in np.arange(2000):           # For 2000 iteractions,\n    x = np.random.randn(1);         # Choose a random (x,y) point in the plane\n    y = np.random.randn(1);\n                                    # Step 1: Calculate known answer.\n    \n                                    # Step 2. Ask perceptron to guess an answer.\n    \n                                    # Step 3. Compute the error.\n    \n                                    # Step 4. Adjust weights according to error.\n     \n    estimated_slope[k] = -wx/wy;    # Compute estimated slope from perceptron.\n    estimated_intercept[k] = -wb/wy;# Compute estimated intercept from perceptron.\n\n# Display the results! ------------------------------------------------------------------------\n# x_range = np.linspace(-2,2,100);                  # For a range of x-values,\n# fig, ax = plt.subplots()\n# ax.plot(x_range, slope*x_range+intercept, 'k')    # ... plot the true line,\n\n# for k in range(1,2000,100):                       # ... and plot some intermediate perceptron guess\n#     ax.plot(x_range, estimated_slope[k]*x_range+estimated_intercept[k], 'r', alpha=0.25)\n                                                  # ... and plot the last perceptron guess\n# plt.xlabel('x')\n# plt.title('Known answer (black), Perceptron final guess (blue)');"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BU MA665 MA666 (Fall 2024)",
    "section": "",
    "text": "Introduction\n\nRead the syllabus.\nPlease complete items in the Introduction.\n\n\n\nIntegrate & Fire Neuron\n\nRead: Abbott, Brain Res Bull (1999) vol. 50 (5-6) pp. 303-4.\nRead: Chapter 1, pages 5-12 @ C. Koch, Biophysics of computation, 1998.\nLecture Slides\nCode: Integrate & Fire Neuron in Python\n\n\n\nHodgkin-Huxley Neuron\n\nRead: Chapter 2, pages 25-42 @ E. Izhikevich, Dynamical Systems in Neuroscience, 2007.\nRead: Hodgkin-Huxley 1-page cheat sheet\nOptional Advanced Read: Hodgkin and Huxley, J Physiol (Lond) (1952) vol. 117 (4) pp. 500-44.\nLecture Slides\nCode: Hodgkin-Huxley Neuron in Python\n\n\n\nPerceptron\n\nLecture Slides\nCode: Training a Perceptron in Python"
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Readings\n\nWilson et al, Good enough practices in scientific computing, 2017.\nRiquelme and Gjorgjieva, Towards readable code in neuroscience, 2021.\n\n\n\nSoftware\n\nSet up Google Colab\nInstall Python via Anaconda\nSet up ChatGPT\n\n\n\nCode\n\nIntroduction to Python\n100 numpy exercises"
  },
  {
    "objectID": "HH.html",
    "href": "HH.html",
    "title": "Hodgkin-Huxley Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the Hodgkin-Huxley (HH) neuron model. This model is arguably the most important computational model in neuroscience. We’ll focus here on simulating this model and understanding its pieces.\n\n1 Preliminaries\nBefore beginning, let’s load in the Python packages we’ll need:\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nIn addition, let’s import the functions we’ll need to simulate the HH model, which are available on this repository:\n\n\nCode\nfrom HH_functions import HH\n\n\n\n\n2 The Hodgkin-Huxley (HH) equation code.\nTo start, let’s examine the code for the HH model. We can do so in (at least) two ways.\n\nGo to the Case Studies repository, and examine the Python file HH_functions.py\nExamine the code inline with inspect\n\n\n\nCode\nimport inspect\ninspect.getsourcelines(HH)\n\n\n(['def HH(I0,T0):\\n',\n  '    dt = 0.01;\\n',\n  '    T  = int(np.ceil(T0/dt))  # [ms]\\n',\n  '    gNa0 = 120   # [mS/cm^2]\\n',\n  '    ENa  = 115;  # [mV]\\n',\n  '    gK0  = 36;   # [mS/cm^2]\\n',\n  '    EK   = -12;  # [mV]\\n',\n  '    gL0  = 0.3;  # [mS/cm^2]\\n',\n  '    EL   = 10.6; # [mV]\\n',\n  '\\n',\n  '    t = np.arange(0,T)*dt\\n',\n  '    V = np.zeros([T,1])\\n',\n  '    m = np.zeros([T,1])\\n',\n  '    h = np.zeros([T,1])\\n',\n  '    n = np.zeros([T,1])\\n',\n  '\\n',\n  '    V[0]=-70.0\\n',\n  '    m[0]=0.05\\n',\n  '    h[0]=0.54\\n',\n  '    n[0]=0.34\\n',\n  '\\n',\n  '    for i in range(0,T-1):\\n',\n  '        V[i+1] = V[i] + dt*(gNa0*m[i]**3*h[i]*(ENa-(V[i]+65)) + gK0*n[i]**4*(EK-(V[i]+65)) + gL0*(EL-(V[i]+65)) + I0);\\n',\n  '        m[i+1] = m[i] + dt*(alphaM(V[i])*(1-m[i]) - betaM(V[i])*m[i]);\\n',\n  '        h[i+1] = h[i] + dt*(alphaH(V[i])*(1-h[i]) - betaH(V[i])*h[i]);\\n',\n  '        n[i+1] = n[i] + dt*(alphaN(V[i])*(1-n[i]) - betaN(V[i])*n[i]);\\n',\n  '    return V,m,h,n,t\\n'],\n 21)\n\n\n\n\n\n\n\n\nQ: Examine this code. Can you make sense of it? Can you identify the gating variables? The rate functions? The equations that define the dynamics? We’ll answer these questions in this in notebook, but try so on your own first.\n\n\n\nWhenever examining code, it’s useful to consider the inputs to the code, and the outputs produced by the code. There are two inputs to HH0:\n\nI0 = the current we inject to the neuron.\nT0 = the total time of the simulation in [ms].\n\nAnd there are five outputs:\n\nV = the voltage of neuron.\nm = activation variable for Na-current.\nh = inactivation variable for Na-current.\nn = activation variable for K-current.\nt = the time axis of the simulation (useful for plotting).\n\n\n\n3 At low input current (I0), examine the HH dynamics.\nTo understand how the HH model works, we’ll start by focusing on the case when I0 is small. Let’s fix the input current to zero,\n\n\nCode\nI0 = 0\n\n\nand let’s simulate the model for 100 ms,\n\n\nCode\nT0 = 100\n\n\nWe’ve now defined both inputs to the HH function, and can execute it, as follows,\n\n\nCode\n[V,m,h,n,t]=HH(I0,T0)\n\n\nNotice that the function returns five outputs, which we assign to the variables V, m, h, n, and t.\n\n\n\n\n\n\nQ: What are the dynamics of the voltage (variable V) resulting from this simulation? HINT: Plot V vs t.\n\n\n\n\n\n\n\n\n\nQ: What are the dynamics of the gating variables (m, h, n) resulting from this simulation? HINT: Plot them!\n\n\n\n\n\n\n\n\n\nQ: What are the final values (after the 100 ms of simulation) of V, m, h, and n?\n\n\n\n\n\n4 At high input current (I0), examine the HH dynamics of a spike.\nLet’s now increase the input current to the HH model and get this model to generate repeated spiking activity. To do so, let’s set,\n\n\nCode\nI0 = 10\n\n\nWe can now simulate this model,\n\n\nCode\n[V,m,h,n,t] = HH(I0,T0)\n\n\n\n\n\n\n\n\nQ: What happens to the dynamics? HINT: Plot V vs t.\n\n\n\n### Observations: You should have found that, at this value of input current, the model generates repeated spikes.\n\nLet’s now explore how the combined gates and dynamics evolve. To do so, let’s start by focusing our plot on a single spike. As a first step, let’s plot the voltage, and choose the time axis to focus on a single spike,\n\n\nCode\n# plt.plot(t,V,'k')\n# plt.xlim([42, 56])\n# plt.ylabel('V [mV]');\n\n\nWe’ve now plotted the voltage dynamics for a single spike (and colored the curve black).\nLet’s now plot the three gating variables. To do so, we’ll make another plot.\nLet’s start by displaying the gating variable m over the same x-limits,\n\n\nCode\n# plt.plot(t,m,'r', label='m')\n# plt.xlim([42, 56]);\n\n\nNotice that, in the call to plot we included the input label. This will be useful when we create a legend. Within this subplot, we can also simultaneously show the gating variables h and n, with the x-axis labeled.\nLet’s also add a legend to help us keep track of the different curves:\n\n\nCode\n# plt.plot(t,m,'r', label='m')\n# plt.plot(t,h,'b', label='h')\n# plt.plot(t,n,'g', label='n')\n# plt.xlim([42, 56])\n# plt.xlabel('Time [ms]');\n# plt.legend();\n\n\n\n\n\n\n\n\nQ: Using the figure you created above, describe how the gates swing open and closed during a spike.\n\n\n\nASIDE: Here’s a nice plotting trick, to link the x-axes of our two subfigures. Linking the axes is useful so that, when we zoom or move one subfigure, the other subfigure will match the x-axis.\n\n\nCode\n# ax1 = plt.subplot(211);                 # Define axis for 1st subplot,\n# ax2 = plt.subplot(212, sharex=ax1);     # ... and link axis of 2nd subplot to the 1st.\n# ax1.plot(t,V,'k')                   # Plot the voltage in the first subplot,\n# plt.xlim([42, 56]);\n# ax2.plot(t,m,'r', label='m')        # ... and the gating variables in the other subplot.\n# ax2.plot(t,h,'b', label='h')\n# ax2.plot(t,n,'g', label='n');\n# plt.xlabel('Time [ms]');\n# plt.legend();\n\n\nNow, in the figure, you may use the pan/zoom tool to adjust the linked subplots.\n\n\n5 At high input current (I0), describe the dynamics of the conductances.\nWe have so far explored how the three gates m, h, and n evolve during a spike. By combining these terms, we can visualize how the conductances evolve during a spike. To do so, let’s stick with the simulation results we generated in the previous section, and focus our plot on a single spike,\n\n\nCode\n# plt.plot(t,V,'k')                   #Plot the voltage,\n# plt.xlim([42, 56])                  #... focused on a single spike,\n# plt.ylabel('V [mV]');               #... with y-axis labeled.\n\n\nNow, to plot the conductances, let’s define three new variables,\n\n\nCode\ngNa0 = 120\ngNa  = gNa0*m**3*h                    # Sodium conductance\ngK0  = 36\ngK   = gK0*n**4                       # Potassium conductance\ngL0  = 0.3\ngL   = gL0*np.ones(np.shape(gK))      # Leak conductance\n\n\n\n\n\n\n\n\nQ: Where do these terms come from?\n\n\n\nThen, let’s plot these conductances,\n\n\nCode\n# plt.plot(t,gNa,'m', label='gNa')#... and plot the sodium conductance,\n# plt.plot(t,gK, 'g', label='gK') #... and plot the potassium conductance,\n# plt.plot(t,gL, 'k', label='gL') #... and plot the leak conductance.\n# plt.xlim([42, 56])                  #... focused on a single spike,\n# plt.xlabel('Time [ms]')             #... label the x-axis.\n# plt.ylabel('mS/cm^2')               #... and label the y-axis.\n# plt.legend();                       #... make a legend.\n\n\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\n\n\n6 At high input current (I0), describe the dynamics of the currents.\nIn the previous section, we explored how the three conductances (gNa, gK, gL) evolve during a spike.\nLet’s now visualize how the ionic currents evolve during a spike.\nTo do so, let’s stick with the same settings used in the previous section and examine the same simulation result. Again, we’ll focus our plot on a single spike.\nNow, to plot the current, let’s define the new variables,\n\n\nCode\ngNa0 = 120\nENa  = 115\nINa  = ??? # Sodium current.\ngK0  = 36\nEK   =-12\nIK   = ??? # Potassium current.\ngL0  = 0.3\nEL   = 10.6;\nIL   = ??? # Leak current.\n\n# plt.plot(t,INa,'m', label='INa')   #... and plot the sodium current,\n# plt.plot(t,IK, 'g', label='IK')    #... and plot the potassium current,\n# plt.plot(t,IL, 'k', label='IL')    #... and plot the leak current.\n# plt.xlim([42, 56])                 #... focus on a single spike,\n# plt.xlabel('Time [ms]')            #... label the x-axis.\n# plt.ylabel('mA/cm^2')              #... and label the y-axis.\n# plt.legend();                      #... make a legend.\n\n\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\n\n\n\n\n\n\nQ: You may notice a small, transient decrease in the sodium current INa near 47 ms. What causes this?\n\n\n\n\n\n7 Discussion\n\nHow is the HH model different from / similar to the IF and LIF models?\nWhat are the ion species simulated in the HH model?\nWhich ion species is fastest / slowest?\nHow many variables are in the HH model? Define each.\nSketch the model equations, in schematic form, to capture the “essence” of the behavior (don’t worry about the detailed values for parameters).\nWhich gating variables are depolarization activated / depolarization inactivated?\nSketch the steady-state curves for the gating variables.\nConsider the current: I_K=g_K n^4  (E_K-V)\n\nDefine each term.\nHow does this current behave for different values of V?\n\nConsider the current: I_Na=g_Na m^3 h (E_Na-V)\n\nDefine each term.\nHow does this current behave for different values of V?\n\n\n\n\n8 Challenges\n\nExplain each line of the Python code that simulates the HH model.\nDescribe the dynamics of the gates and ions during an action potential in the HH model.\nDetermine how the firing rate of the HH model varies with input current I. Plot the firing rate versus I (i.e., plot the “f-I curve”).\nHow do the dynamics change as you increases / decrease the potassium conductance?\nHow do the dynamics change as you increases / decrease the sodium conductance?"
  }
]