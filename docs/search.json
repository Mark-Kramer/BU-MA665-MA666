[
  {
    "objectID": "IF.html",
    "href": "IF.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All Code\n\n\n\n\nIn this notebook we will use Python to simulate the integrate and fire (I&F) neuron model. We’ll investigate, in particular, how the spiking activity varies as we adjust the input current \\(I\\).\n\n1 Preliminaries\nBefore beginning, let’s load in the Python package we’ll need:\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n\n2 Numerical solutions - Introduction\nHow do we compute a numerical solution to the integrate and fire model? The basic idea is to rearrange the differential equation to get \\(V(t+1)\\) on the left hand side, and \\(V(t)\\) on the right hand side. Then, if we know what’s happening at time \\(t\\), we can solve for what’s happening at time \\(t+1\\).\nFor example, consider the differential equation:\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{I}{C}\n\\]\nIn words, we can think of:\n\\(dV\\) as the “change in voltage V”,\n\\(dt\\) as the “change in time t”.\nLet’s consider the case that we record the voltage \\(V\\) in discrete time steps. So we observe:\n\\(V[0], V[1], V[2], \\ldots\\)\nat times:\n\\(dt, \\, 2*dt, \\, 3*dt, \\ldots\\)\nwhere \\(dt\\) is the time between our samples of \\(V\\).\nWe can now write the “change in voltage V” as:\n\\[\n  dV = V(t+1) - V(t)\n\\]\nNotice that the change in voltage is the difference in V between two sequential time samples. Now, let’s rewrite \\(\\dfrac{dV}{dt}\\) as,\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt }\n\\]\nwhere we’ve replaced \\(dV\\). Now, let’s substitute this expression into the equation at the top of this file:\n\\[\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n\\]\nSolving this equation for \\(V(t+1)\\) you’ll find that:\n\\[\n  V(t+1) = V(t) + dt*(I/C)\n\\]\nNotice that, in this expression, we use our current value of the voltage V(t) and the model (I/C) to determine the next value of the voltage V(t+1).\nNow, let’s program this equation in Python. First, let’s set the values for the parameters \\(I\\) and \\(C\\).\n\n\nCode\nC=1.0\nI=1.0\n\n\nWe also need to set the value for \\(dt\\). This defines the time step for our model. We must choose it small enough so that we don’t miss anything interesting. We’ll choose:\n\n\nCode\ndt=0.01\n\n\nLet’s assume the units of time are seconds. So, we step forward in time by \\(0.01\\) s.\nThe right hand side of our equation is nearly defined, but we’re still missing one thing, \\(V(t)\\).\n\n\n\n\n\n\nQ: What value do we assign to \\(V(t)\\)?\n\n\n\nSo here’s an easier question: what initial value do we assign to \\(V(t)\\)?\nTo start, we’ll create an array of zeros to hold our results for \\(V\\):\n\n\nCode\nV = np.zeros([1000,1])\nV.shape\n\n\n(1000, 1)\n\n\nThis array V consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of V (i.e., step forward in time), in a way consistent with our model.\nLet’s choose an initial value for V of 0.2, which in our simple model we’ll assume represents the rest state.\n\n\nCode\nV[0]=0.2\n\n\n\n\n\n\n\n\nQ: Given the initial state V[0]=0.2, calculate V[1]. Then calcualte V[2].\n\n\n\nAfter the two calculations above, we’ve moved forward two time steps into the future, from \\(t=0\\) s to \\(t=0.01\\) s, and then from \\(t=0.01\\) s to \\(t=0.02\\) s. But what if we want to know \\(V\\) at \\(t=10\\) s? Then, this iteration-by-hand procedure becomes much too boring and error-prone. So, what do we do? Let’s make the computer do it …\n\n\n3 Numerical solutions - Implementation\nLet’s computerize this iteration-by-hand procedure to find V[999].\nTo do so, we’ll use a for-loop.\nHere’s what it looks like:\n\n\nCode\nfor k in range(1,999):\n    V[k+1] = V[k] + dt*(I/C)\n\n\n\n\n\n\n\n\nQ: Does this loop make sense? Describe what’s happening here.\n\n\n\n\n\n\n\n\n\nQ: Why does the range command end at 999?\n\n\n\nExecute this for-loop and examine the results in vector V. To do so, let’s plot V:\n\n\nCode\n# plt.plot(V);\n\n\n\n\n\n\n\n\nQ: What happens to the voltage after 1000 steps?\n\n\n\nThis plot is informative, but not great. Really, we’d like to plot the voltage as a function of time, not steps or indices. To do so, we need to define a time axis:\n\n\nCode\nt = np.arange(0,len(V))*dt\n\n\n\n\n\n\n\n\nQ: What’s happening in the command above? Does it make sense? (If not, trying printing or plotting t.)\n\n\n\nNow, with time defined, let’s redo the plot of the voltage with the axes labeled appropriately.\n\n\nCode\n# plt.plot(t,V)\n# plt.xlabel('Time [s]');\n# plt.ylabel('V');\n\n\nFinally, let’s put it all together . . .\n\n\n4 I&F CODE (version 1)\nSo far, we constructed parts of the I&F model in bits-and-pieces. Let’s now collect all the code, compute a numerical solution to the I&F model, and plot the results (with appropriate axes).\nFirst, let’s clear all the variables:\n\n\nCode\n%reset\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nI   = 1                           #Set the parameter I.\nC   = 1                           #Set the parameter C.\ndt  = 0.01                        #Set the timestep.\nV   = np.zeros([1000,1])             #Initialize V.\nV[0]= 0.2;                        #Set the initial value of V.\n\nfor k in range(1,999):            #March forward in time,\n    V[k+1] = V[k] + dt*(I/C)      #... updating V along the way.\n\nt = np.arange(0,len(V))*dt        #Define the time axis.\n\n#plt.plot(t,V)                         #Plot the results.\n#plt.xlabel('Time [s]')\n#plt.ylabel('Voltage [mV]');\n\n\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=0? Can you set I so that V &gt; 20 within 10 s?\n\n\n\n\n\n5 Voltage threshold\nNotice, our model is missing something important: the reset.\n\n\n\n\n\n\nQ: Without the reset, how does the voltage behave as \\(t\\rightarrow\\infty\\) (if \\(I&gt;0\\))?\n\n\n\nNow, let’s update our model to include the reset. To do so, we’ll add two things to our code.\n\nFirst, we’ll define the voltage threshold Vth, and reset voltage Vreset.\nSecond, we’ll check to see if V exceeds Vth using an if-statement; if it does, then we’ll set V equal to Vreset.\n\n\n\n\n\n\n\nQ: How will you update the code below to include the reset?\n\n\n\n\n\nCode\nVth = 1;        #Define the voltage threshold.\nVreset = 0;     #Define the reset voltage.\n\nfor k in range(1,999):            #March forward in time,\n    V[k+1] = V[k] + dt*(I/C)      #Update the voltage,\n    ### ADD SOMETHING HERE??? --------------------------\n\n\n\n\n6 I&F CODE (version 2)\nNow, let’s put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\n\nCode\n%reset\n\n\nOnce deleted, variables cannot be recovered. Proceed (y/[n])?  y\n\n\n\n\nCode\n### ADD YOUR CODE!\n\n\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=10? If I=100?\n\n\n\n\n\n\n\n\n\nQ: Adjust the parameter C. What happens to V if C=0.1? If C=10?\n\n\n\n\n\n\n\n\n\nQ: What is “spiking” in this I&F model?\n\n\n\n\n\n7 Discussion\n\nDescribe the main components of the IF model. Draw it (in some way).\nDescribe the main components of the LIF model. Draw it (in some way).\nDescribe the differences and similarities between the IF and LIF models.\nThe IF model is meant to mimic a neurons activity. Describe what is realistic about the IF model? What is unrealistic?\nDescribe the roles of the IF model parameters Vreset and Vthreshold.\nConsider the IF model. Sketch voltage (V) versus time (t) for a small input current, for a large input current.\n\nHow does an increase in capacitance (C) impact the dynamics?\nCan you interpret this physically?\n\n\n\n\n8 Challenges\n\nConsider the LIF model. Plot (in Python) voltage (V) versus time (t) for a small input current, for a large input current.\nHow does an increase in the capacitance (C) impact the dynamics of the LIF model?\nHow does an increase in the resistance (R) impact the dynamics of the LIF model?\nDetermine how the firing rate of the LIF model varies with input I. Plot the firing rate versus I (i.e., plot the “f-I curve”).\nADVANCED. Simulate the Izhikevich neuron. Provide examples of two different types of spiking activity."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BU MA665 MA666 (Fall 2024)",
    "section": "",
    "text": "Introduction\n\nRead the syllabus.\nPlease complete items in the Introduction.\n\n\n\nIntegrate & Fire Neuron\n\nRead: Abbott, Brain Res Bull (1999) vol. 50 (5-6) pp. 303-4.\nRead: Chapter 1, pages 5-12 @ C. Koch, Biophysics of computation, 1998.\nLecture Slides\nCode: Integrate & Fire Neuron in Python\n\n\n\nHodgkin-Huxley Neuron"
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Readings\n\nWilson et al, Good enough practices in scientific computing, 2017.\nRiquelme and Gjorgjieva, Towards readable code in neuroscience, 2021.\n\n\n\nSoftware\n\nSet up Google Colab\nInstall Python via Anaconda\nSet up ChatGPT\n\n\n\nCode\n\nIntroduction to Python\n100 numpy exercises"
  }
]