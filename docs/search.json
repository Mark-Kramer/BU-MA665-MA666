[
  {
    "objectID": "IF.html",
    "href": "IF.html",
    "title": "Integrate and Fire Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the integrate and fire (I&F) neuron model. We’ll investigate, in particular, how the spiking activity varies as we adjust the input current \\(I\\).\n\n1 Preliminaries\nBefore beginning, let’s load in the Python package we’ll need:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2 Numerical solutions - Introduction\nHow do we compute a numerical solution to the integrate and fire model? The basic idea is to rearrange the differential equation to get \\(V(t+1)\\) on the left hand side, and \\(V(t)\\) on the right hand side. Then, if we know what’s happening at time \\(t\\), we can solve for what’s happening at time \\(t+1\\).\nFor example, consider the differential equation:\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{I}{C}\n\\]\nIn words, we can think of:\n\\(dV\\) as the “change in voltage V”,\n\\(dt\\) as the “change in time t”.\nLet’s consider the case that we record the voltage \\(V\\) in discrete time steps. So we observe:\n\\(V[0], V[1], V[2], \\ldots\\)\nat times:\n\\(dt, \\, 2*dt, \\, 3*dt, \\ldots\\)\nwhere \\(dt\\) is the time between our samples of \\(V\\).\nWe can now write the “change in voltage V” as:\n\\[\n  dV = V(t+1) - V(t)\n\\]\nNotice that the change in voltage is the difference in V between two sequential time samples. Now, let’s rewrite \\(\\dfrac{dV}{dt}\\) as,\n\\[\n  \\dfrac{dV}{dt} = \\dfrac{ V(t+1) - V(t) }{ dt }\n\\]\nwhere we’ve replaced \\(dV\\). Now, let’s substitute this expression into the equation at the top of this file:\n\\[\n  \\dfrac{ V(t+1) - V(t) }{ dt } = \\dfrac{I}{C}.  \n\\]\nSolving this equation for \\(V(t+1)\\) you’ll find that:\n\\[\n  V(t+1) = V(t) + dt*(I/C)\n\\]\nNotice that, in this expression, we use our current value of the voltage V(t) and the model (I/C) to determine the next value of the voltage V(t+1).\nNow, let’s program this equation in Python. First, let’s set the values for the parameters \\(I\\) and \\(C\\).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe also need to set the value for \\(dt\\). This defines the time step for our model. We must choose it small enough so that we don’t miss anything interesting. We’ll choose:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s assume the units of time are seconds. So, we step forward in time by \\(0.01\\) s.\nThe right hand side of our equation is nearly defined, but we’re still missing one thing, \\(V(t)\\).\n\n\n\n\n\n\nQ: What value do we assign to \\(V(t)\\)?\n\n\n\nSo here’s an easier question: what initial value do we assign to \\(V(t)\\)?\nTo start, we’ll create an array of zeros to hold our results for \\(V\\):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis array V consists of 1000 rows and 1 column. We can think of each row entry as corresponding to a discrete step in time. Our goal is to fill-in the values of V (i.e., step forward in time), in a way consistent with our model.\nLet’s choose an initial value for V of 0.2, which in our simple model we’ll assume represents the rest state.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Given the initial state V[0]=0.2, calculate V[1]. Then calcualte V[2].\n\n\n\nAfter the two calculations above, we’ve moved forward two time steps into the future, from \\(t=0\\) s to \\(t=0.01\\) s, and then from \\(t=0.01\\) s to \\(t=0.02\\) s. But what if we want to know \\(V\\) at \\(t=10\\) s? Then, this iteration-by-hand procedure becomes much too boring and error-prone. So, what do we do? Let’s make the computer do it …\n\n\n3 Numerical solutions - Implementation\nLet’s computerize this iteration-by-hand procedure to find V[999].\nTo do so, we’ll use a for-loop.\nHere’s what it looks like:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Does this loop make sense? Describe what’s happening here.\n\n\n\n\n\n\n\n\n\nQ: Why does the range command end at 999?\n\n\n\nExecute this for-loop and examine the results in vector V. To do so, let’s plot V:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What happens to the voltage after 1000 steps?\n\n\n\nThis plot is informative, but not great. Really, we’d like to plot the voltage as a function of time, not steps or indices. To do so, we need to define a time axis:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What’s happening in the command above? Does it make sense? (If not, trying printing or plotting t.)\n\n\n\nNow, with time defined, let’s redo the plot of the voltage with the axes labeled appropriately.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nFinally, let’s put it all together . . .\n\n\n4 I&F CODE (version 1)\nSo far, we constructed parts of the I&F model in bits-and-pieces. Let’s now collect all the code, compute a numerical solution to the I&F model, and plot the results (with appropriate axes).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=0? Can you set I so that V &gt; 20 within 10 s?\n\n\n\n\n\n5 Voltage threshold\nNotice, our model is missing something important: the reset.\n\n\n\n\n\n\nQ: Without the reset, how does the voltage behave as \\(t\\rightarrow\\infty\\) (if \\(I&gt;0\\))?\n\n\n\nNow, let’s update our model to include the reset. To do so, we’ll add two things to our code.\n\nFirst, we’ll define the voltage threshold Vth, and reset voltage Vreset.\nSecond, we’ll check to see if V exceeds Vth using an if-statement; if it does, then we’ll set V equal to Vreset.\n\n\n\n\n\n\n\nQ: How will you update the code below to include the reset?\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n6 I&F CODE (version 2)\nNow, let’s put it all together to make a complete I&F model (with a thershold and reset), simulate it, and plot the result.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Adjust the parameter I. What happens to V if I=10? If I=100?\n\n\n\n\n\n\n\n\n\nQ: Adjust the parameter C. What happens to V if C=0.1? If C=10?\n\n\n\n\n\n\n\n\n\nQ: What is “spiking” in this I&F model?\n\n\n\n\n\n\n7 Discussion\n\nDescribe the main components of the IF model. Draw it (in some way).\nDescribe the main components of the LIF model. Draw it (in some way).\nDescribe the differences and similarities between the IF and LIF models.\nThe IF model is meant to mimic a neurons activity. What is realistic about the IF model? What is unrealistic?\nDescribe the roles of the IF model parameters Vreset and Vthreshold.\nConsider the IF model. Sketch voltage (V) versus time (t) for a small input current, for a large input current.\n\nHow does an increase in capacitance (C) impact the dynamics?\nCan you interpret this physically?\n\nPlot the f-I curve for the IF model.\n\n\n\n\n8 Challenges\n\nConsider the LIF model. Plot (in Python) voltage (V) versus time (t) for a small input current, for a large input current.\nPerform numerical simulations to determine how doubling the capacitance (C) impacts the firing rate of the LIF model. Based on your numerical simulations, does the firing rate increase or decrease? Provide a physical explanation for your results (i.e., how does the charge move around the circuit to impact the firing rate?) HINT: Capacitance represents the capacity of a cell to hold charge.\nPerform numerical simulations to determine how doubling the resistance (R) impacts the firing rate of the LIF model. Based on your numerical simulations, does the firing rate increase or decrease? Provide a physical explanation for your results (i.e., how does the charge move around the circuit to impact the firing rate?) HINT: Higher resistance makes it harder for charge to flow in or out of the cell.\nDetermine how the firing rate of the LIF model varies with input I. Plot the firing rate versus I (i.e., plot the “f-I curve”).\nADVANCED. Simulate the Izhikevich neuron. Provide examples of two different types of spiking activity."
  },
  {
    "objectID": "Perceptron.html",
    "href": "Perceptron.html",
    "title": "Perceptron",
    "section": "",
    "text": "In this notebook, we will construct simple perceptron models. We’ll start by implementing a perceptron model, and seeing how it behaves. We’ll then outline the steps to train a perceptron to classify a point as above or below a line.\nThis discussion follows the excellent example and discussion at The Nature of Code. Please see that reference for additional details, and a more sophisticated coding strategy (using Classes in Python)."
  },
  {
    "objectID": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "href": "Perceptron.html#provide-perceptron-with-inputs-and-known-answer.",
    "title": "Perceptron",
    "section": "3.1 Provide perceptron with inputs and known answer.",
    "text": "3.1 Provide perceptron with inputs and known answer.\nFirst, let’s make a function that computes a line, and determines if a given y value is above or below the line. We’ll use this function to return the correct (“known”) answer. Having known answers is important for training the perceptron. We’ll use the known answers to tell the when it’s right or wrong (i.e., when the perceptron makes an error).\nLet’s define the function (known_answer) should take four inputs:\n\nslope\nintercept\nx\ny\n\nwhere the (x,y) value is a point we choose on the plane. The function should return one output:\n\ndesired_output\n\nwhere,\ndesired_output = 1, if the y value (the last input) is above the line,\ndesired_putput = 0, if the y value (the last input) is below the line.\nComplete the function below:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand the line with slope and intercept,\n\n\nslope = 2  intercept = 1\n\n\nIs the (x,y) point above or below the line?\n\n\n\nA: To answer this, let’s ask our function,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nA (Continued): We find a correct_answer of 1.\n\n\nSo, the point (x,y)=(0.7,3) is above the line with slope 2 and intercept 1."
  },
  {
    "objectID": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "href": "Perceptron.html#ask-perceptron-to-guess-an-answer.",
    "title": "Perceptron",
    "section": "3.2 Ask perceptron to guess an answer.",
    "text": "3.2 Ask perceptron to guess an answer.\nOur next step is to compare our desired output (computed in Step 1) to the output guessed by the perceptron. To do so, we’ll need to compute the feedforward solution for the perceptron (i.e., given the inputs and bias, determine the perceptron output). Let’s do so complete the function below,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis function takes five inputs:\n\nx = the x coordinate of the point we choose in the plane.\ny = the y coordinate of the point we choose in the plane.\nwx = the weight of x input.\nwy = the weight of y input.\nwb = the weight of the bias.\n\nAnd this function returns one output:\n\nthe perceptron’s guess, is the point above (=1) or below (=0) the line.\n\n\n\n\n\n\n\nQ: Again consider the (x,y) point,\n\n\nx,y = 0.7,3\n\n\nand set initial values for the perceptron weights. Let’s just set these all to 0.5; our goal in the rest of this module will be to train the perceptron by adjusting these weights. But for now,\n\n\nwx,wy,wb = 0.5\n\n\nThen, ask the perceptron for it’s guess for it’s guess, is the point above or below the line?\n\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nA: We find a peceptron_guess of 1.\nSo, the perceptron guesses that the point (x,y)=(0.7,3) is above the line."
  },
  {
    "objectID": "Perceptron.html#compute-the-error.",
    "href": "Perceptron.html#compute-the-error.",
    "title": "Perceptron",
    "section": "3.3 Compute the error.",
    "text": "3.3 Compute the error.\nWe’ve now answered the question “Is the (x,y) point above the line?” in two ways:\n\nthe known answer, and\nthe perceptron’s guess.\n\nLet’s compute the error as the difference between these two answers:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What do you find for the error? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "href": "Perceptron.html#adjust-all-weights-according-to-the-error.",
    "title": "Perceptron",
    "section": "3.4 Adjust all weights according to the error.",
    "text": "3.4 Adjust all weights according to the error.\nTo update the weights, we’ll use the expression,\nnew weight = weight + error * input * learning constant\nWe need to compute this for each weight (wx, wy, wb).\nFirst, let’s set the learning constant,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThen, we can compute the new weights,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that, in the update to wb we use the fact that the bias equals 1.\n\n\n\n\n\n\nQ: What do you find for the new weights? Does it make sense?"
  },
  {
    "objectID": "Perceptron.html#return-to-step-1-and-repeat",
    "href": "Perceptron.html#return-to-step-1-and-repeat",
    "title": "Perceptron",
    "section": "3.5 Return to Step 1 and repeat …",
    "text": "3.5 Return to Step 1 and repeat …\nWe could try to compute these repetitions by hand, for example by repeating the cells above. To do so, we’d choose a new point in the (x,y) plane, determine whether it’s above the line 2x+1, ask the perceptron to guess whether it’s above the line, then use the error to update the perceptron’s weights.\nBut we want to evaluate this procedure 2000 times. Doing so by hand would be a total pain, and highly error prone. Instead, let’s ask the computer to do the boring work of multiple repetitions. To do so, let’s collect the code above, and examine 2000 (x,y) points chosen randomly in the plane. We’ll wrap our code above inside a for-loop to make this efficient,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "Rhythms_1.html",
    "href": "Rhythms_1.html",
    "title": "Rhythms 1",
    "section": "",
    "text": "In this notebook we will simulate rhythmic activity as a first step in our understanding of brain rhythms.\n\n\nCode\n# Load modules\nimport scipy.io as sio\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n1 Making sinusoids\nIt’s relatively easy to make sinusoids in Python, using built-in commands. There are many ways to do so, and we’ll start here by constructing a time axis. Consider the following:\n\n\nCode\nt = np.arange(0, 2, 0.001)\n\n\n\n\n\n\n\n\nQ: The variable t defines a time axis. When does time start? When does time end? What is the sampling interval (i.e., the time between samples)?\n\n\n\nNow, let’s define a new variable that represents a sinusoid,\n\n\nCode\nx = np.sin(2*np.pi*t)\n\n\n\n\n\n\n\n\nQ: Is “x” a sinusoid? What is the frequency of the oscillation?\n\n\n\n\n\n\n\n\n\nQ: How would you update “x” to create a sine function that oscillates at 10 Hz?\n\n\n\n\n\n\n\n\n\nQ: How would you create a cosine function that oscillates at 14 Hz?\n\n\n\n\n\n2 Orthogonality of sinusoids\nAn important feature of sinusoids is orthogonality.\nBriefly, if we multiply together two cosine functions, and sum the resulting product, we get zero unless the frequencies match.\nLet’s illustrate this idea in Python. To do so, first define two sinusoids,\n\n\nCode\nf1 = 10;\nx1 = np.cos(2*np.pi*t*f1);\n\nf2 = 2;\nx2 = np.cos(2*np.pi*t*f2);\n\n\n\n\n\n\n\n\nQ: What is the frequency of each sinusoid? Plot these sinusoids to see how they behave.\n\n\n\nTo check orthogonality, we want to multiply together these two cosine functions, point-by-point at each time, then sum their product over all time.\n\n\n\n\n\n\nQ: How do we perform this operation in Python? Do so, and report what you find.\n\n\n\n\n\n\n\n\n\nQ: How does this result change for different choices of f1 and f2?\n\n\n\n\n\n3 Decomposing a sinusoid into one component\nWe’ll now consider a more complicated signal. Please download the data Rhythms_1.mat and load the data,\n\n\nCode\ndata = sio.loadmat('Data/Rhythms_1.mat')       # Load the experimental data\nd1   = data['d1']\nt    = data['t']\n\n\n\n\n\n\n\n\nQ: What variables appear? What are the dimensions of each? What is the sampling interval? What is the total duration of the data?\n\n\n\n\n\n\n\n\n\nQ: By visual inspection of the data, what frequencies dominate the signal?\n\n\n\nNow, we’d like to “compare” sinusoids with known frequency to the data.\nIn doing so, our goal is to identify those sinusoids that “best match” the data; this will reveal the rhythms that appear in the signal, which we will ultimately display graphically in a power spectrum.\nTo begin this process, we’ll specify a handful of frequencies to consider.\nLet’s start with a sine function oscillating at 1 Hz.\n\n\n\n\n\n\nQ: Define a 1 Hz sine function that lasts for the duration of the data, and has the same sampling interval (i.e., the same time axis as the data).\n\n\n\nWith the sine function now defined, let’s “compare” it to the data\nTo do so, we multiply point-by-point the data and sine function and sum the result.\nBecause we’re approximating an integral, we’ll need to include the differential (dt) in the sum.\n\n\n\n\n\n\nQ: How do we compute this integral?\n\n\n\n\n\n\n\n\n\nQ: Consider your result for this integral. Does the 1 Hz sine function make a significant contribution to the data? Is the result of this integral consistent with your visual inspection of the data?\n\n\n\n\n\n4 Decomposing a sinusoid into many components\nNow, we’ve compared a single sinusoid - the 1 Hz sine function - to the data.\nIn this case, we’ve found that the corresponding integral is small.\nHowever, we’re not interested in only this sinusoid; we’d really like to consider a range of sinusoids (both sine and cosine functions) oscillating at different frequencies.\nOur goal in this part of notebook is to do so, and compare the data to sinusoids at different frequencies.\n\n\n\n\n\n\nQ: Compare the data to sinusoids at integer frequencies {1,2,3, …, 10} Hz. Save your results for each frequency of the cosine function in a variable called “A”, and the results for each frequency of the sine function in a variable called “B”.\nHINT: There are many ways to compute these comparisons. You might perform each computation “by hand” (e.g., compute A at 1 Hz, B at 1 Hz, A at 2 Hz, B at 2 Hz, . . . ). In doing so, you’ll notice a lot of repetition. Is there a more efficient way to perform so many similar computations?"
  },
  {
    "objectID": "Regression.html",
    "href": "Regression.html",
    "title": "Regression",
    "section": "",
    "text": "In this notebook, we’ll implement an example application of linear regression applied to behavioral and electrophysiologicial data.\n\n\nCode\n# Load modules\nimport scipy.io as sio\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import pearsonr\nimport statsmodels.api as sm\n\n\n\n1 Load the data\nThe example behavioral and electrophysiologicial data is regression_example_data.mat. Get these data, and load them:\n\n\nCode\ndata             = sio.loadmat('Data/regression_example_data.mat')       # Load the experimental data\ntask_performance = data['task_performance']\nfiring_rate      = data['firing_rate']\n\n\n\n\n2 Visualize the data\n\n\nCode\n# Plot it ...\nplt.xlabel('Firing rate [Hz]')\nplt.ylabel('Task Performance [a.u.]');\n\n\n\n\n\n\n\n\n\n\n\n3 Correlation\nCompute the correlation between \\(x\\) and \\(y\\).\n\n\nCode\nN = firing_rate[:,0].size\nx = firing_rate[:,0] - firing_rate[:,0].mean()\ny = task_performance[:,0] - task_performance[:,0].mean()\ncorrelation = 'Correlation Calculation'\nprint(correlation)\n\n\nCorrelation Calculation\n\n\n\n\n4 Regression (compute it)\nModel the data using regression.\n\n\nCode\nfrom statsmodels.formula.api import ols\n\ndata = {\"x\": firing_rate, \"y\": task_performance}\n\nres1 = ols(\"y ~1 + x\", data=data).fit()\nres1.summary()\n\n\n\nOLS Regression Results\n\n\nDep. Variable:\ny\nR-squared:\n0.000\n\n\nModel:\nOLS\nAdj. R-squared:\n-0.021\n\n\nMethod:\nLeast Squares\nF-statistic:\n0.001521\n\n\nDate:\nMon, 12 Aug 2024\nProb (F-statistic):\n0.969\n\n\nTime:\n15:37:13\nLog-Likelihood:\n-119.04\n\n\nNo. Observations:\n50\nAIC:\n242.1\n\n\nDf Residuals:\n48\nBIC:\n245.9\n\n\nDf Model:\n1\n\n\n\n\nCovariance Type:\nnonrobust\n\n\n\n\n\n\n\n\n\n\n\ncoef\nstd err\nt\nP&gt;|t|\n[0.025\n0.975]\n\n\nIntercept\n15.0190\n4.037\n3.720\n0.001\n6.901\n23.137\n\n\nx\n0.0158\n0.404\n0.039\n0.969\n-0.797\n0.829\n\n\n\n\n\n\n\n\nOmnibus:\n4.793\nDurbin-Watson:\n1.865\n\n\nProb(Omnibus):\n0.091\nJarque-Bera (JB):\n3.249\n\n\nSkew:\n0.459\nProb(JB):\n0.197\n\n\nKurtosis:\n2.153\nCond. No.\n108.\n\n\n\nNotes:[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\n\n\n\n5 Regression (plot it)\nPlot the estimated regression model with the data.\n\n\nCode\n# Get model prediction.\npred   = res1.get_prediction().summary_frame()\nmn     = pred['mean']\nci_low = pred['mean_ci_lower'] \nci_upp = pred['mean_ci_upper']\n# And plot it.\nindices_sorted = np.argsort(firing_rate,0)\nplt.scatter(firing_rate,task_performance)\nplt.plot(firing_rate[indices_sorted[:,0]],mn[indices_sorted[:,0]], 'r')\nplt.plot(firing_rate[indices_sorted[:,0]],ci_low[indices_sorted[:,0]], ':r')\nplt.plot(firing_rate[indices_sorted[:,0]],ci_upp[indices_sorted[:,0]], ':r')\nplt.xlabel('Firing rate [Hz]')\nplt.ylabel('Task Performance [a.u.]');\n\n\n\n\n\n\n\n\n\n\n\n\n6 Regression example (Part 2)\nWe learn that an additional predictor - age - impacts task performance.\n\n\nCode\n## Load the data, now with age.\ndata             = sio.loadmat('Data/regression_example_data.mat')       # Load the experimental data\ntask_performance = data['task_performance']\nfiring_rate      = data['firing_rate']\nage              = data['age']\n\n\n\n\n7 Visualize the new data\n\n\nCode\n# Plot it ...\nplt.xlabel('Age [years]');\nplt.ylabel('Task Performance [a.u.]');\n\n\n\n\n\n\n\n\n\n\n\n8 Correlation (between task performance and age)\n\n\nCode\n# Compute the correlation between task performance and age\n\n\n\n\n9 Visualize all data\n\n\nCode\nfig = plt.figure(figsize=(12, 12))\nax  = fig.add_subplot(projection='3d')\nax.scatter(age, firing_rate, task_performance)\nax.set_xlabel('Age [yrs]')\nax.set_ylabel('Firing Rate [Hz]')\nax.set_zlabel('Task Performance');\n\n\n\n\n\n\n\n\n\n\n\n10 Regression (compute it with all data)\nModel all data using regression.\n\n\nCode\nfrom statsmodels.formula.api import ols\ndata = {\"firing_rate\": firing_rate, \"age\": age, \"y\": task_performance}\n# Write the model and print out the summary\n\n\n\n\n11 Regression (plot it with all data)\nPlot the estimated regression model with two predictors and all data.\n\n\nCode\n# And plot the mean model fit.\nfig = plt.figure(figsize=(10, 10))\nax  = fig.add_subplot(projection='3d')\nax.set_xlabel('Age [yrs]')\nax.set_ylabel('Firing Rate [Hz]')\nax.set_zlabel('Task Performance');\nax.scatter(age, firing_rate, task_performance);\nx = np.arange(8, 12, 0.1)  # Firing rate\ny = np.arange(10,20, 0.1)  # Age\nxx, yy = np.meshgrid(x, y) # Model\n# zz = res.params[0] + res.params[1]*xx + res.params[2]*yy\n# ax.plot_surface(yy,xx,zz);"
  },
  {
    "objectID": "Introduction.html",
    "href": "Introduction.html",
    "title": "Introduction to Python for the practicing neuroscientist",
    "section": "",
    "text": "To be frank: this notebook is rather boring. In this class, we will use the software package Python. The best way to learn new software (and probably most things) is when motivated by a particular problem. Would you read assembly instructions for furniture you do not plan to own? Probably not. In other notebooks we will pursue specific questions driven by neuronal data, and use our desire to understand these data to motivate the development and application of computational methods. But not in this notebook. Here, we focus on basic coding techniques and principles in Python in the abstract, without motivation. You - poor learner - must trust that these ideas and techniques will eventually be useful. We begin by dipping our toe into the Python pool, and learning the basic strokes; the fun and interesting parts in the “real world” of neuronal data happen later.\nLet us delay no further. In the following examples, you are asked to execute code in Python. If your Python experience is limited, you should actually do this, not just read the text below. If you intend to ignore this advice - and not execute the code in Python - then instead walk to the local coffee shop, get a double espresso, and return to attempt these examples.\nThis notebook follows in spirit and sometimes in detail notebook 2 of MATLAB for Neuroscientists, an excellent reference for learning to use MATLAB in neuroscience with many additional examples. If you have not used Python before, there are many excellent resources online (e.g., the Python Data Science Handbook).\n\nStarting Python\nThere are two ways to interact with this notebook. First, you could run it locally on your own computer using Jupyter. This is an excellent choice, because you’ll be able to read, edit, and excute the Python code directly and you can save any changes you make or notes that you want to record. The second way is to open this notebook in your browser and execute the examples directly in your browser, without installing additional software on your computer. In any case, we encourage you to execute each line of code in this file!\n\n\n\n\n\n\nNote\n\n\n\nThroughout this notebook, we assume that you are running Python 3. Most of the functions used here are the same in Python 2 and 3. One noteable exception however is division. If you are using Python 2, you will find that the division operator / actually computes the floor of the division if both operands are integers (i.e., no decimal points). For example, in Python 2, 4/3 equals 1. While, in Python 3, 4/3 equals 1.333.\nWe encourage you to use Python 3 for the sake of compatibility with this notebook, as well as for compatibility with future releases of Python.\n\n\n\n\nOn-ramp: analysis of neural data in Python\nWe begin this notebook with an “on-ramp” to analysis in Python. The purpose of this on-ramp is to introduce you immediately to some aspects of Python. You may not understand all aspects of the Python language here, but that’s not the point. Instead, the purpose of this on-ramp is to illustrate what can be done. Our advice is to simply run the code below and see what happens…\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Try to read the code above. Can you see how it loads data, extracts useful information to print, then selects an interval of data to plot?\nA: If you’ve never used Python before, that’s an especially difficult question. Please continue on to learn more!\n\n\n\n\n\nExample 1: Python is a calculator\nExecute the following commands in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What does Python return? Does it make sense?\n\n\n\n\n\nExample 2. Python can compute complicated quantities.\nEnter the following command in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Does this answer make sense?\n\n\n\n\n\n\n\n\n\nQ: Can you use parentheses to change the answer?\n\n\n\n\n\nExample 3. Python has useful built in functions.\nA function is a program that operates on arguments. Standard math functions and variables (and other useful things) can be accessed from the math and numpy modules. To use the math and numpy modules, we must first import both:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nIn this style, we indicate which module, or namespace, contains the function we want to call: x = np.arange(10) or plt.plot(x, y).\n\n\nYou will often begin your data analysis with import statements, to load the functionality you need. We can now call functions from math using numpy.*. For example,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAbove, sin is the sine function. It operates on the argument 2*pi. Notice that, once we have imported the numpy module, Python knows the value of pi. Here’s another example function that operates on arguments:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What is math.atan?\nA: To answer this, try using Python Help. To start the Python Help, simply put a ? at the end of math.atan and then run this code block.\n\n\n\n\n\nCode\nmath.atan?\n\n\nYou should see a description of the function pop up at the bottom of the window.\n\n\n\n\n\n\nNote\n\n\n\nPython Help is extremely useful, but may not work in a web browser. You can always look there when you have questions about a function, or search the internet for help, i.e., google it.\n\n\n\n\nExample 4. We can use Python to define lists of numbers.\nIn Python, there are several different data structures that are designed to store more than one element. Here we will focus on the array data structure, but if you are curious to know how and when to use other structures, there is a good explanation here. Let’s define an array:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 5. We can manipulate arrays by scalars.\nA scalar is a single number. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What do you find?\nA: Notice that the scalar operates on each element of the array.\n\n\n\n\n\nExample 6. We can manipulate arrays with arrays.\nLet’s create an array and multiply it by itself,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What does this return?\nA: We see that the operator * performs element-by-element multiplication of the values in array a.\n\n\n\n\n\nExample 7. More examples of manipulating arrays with arrays.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What operation does np.multiply() perform?\n\n\n\n\n\nExample 8. We can probe the variables we’ve defined in Python.\nTo see a list of the variables you’ve defined, type who or whos in a code block by themselves. Notice whos provides more information.\n\n\nCode\nwho\n\n\nInteractive namespace is empty.\n\n\n\n\nCode\nwhos\n\n\nInteractive namespace is empty.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe functions who and whos can be extremely useful, but may not work in a web browser.\n\n\n\n\nExample 9. Determine the dimensions of an array\nTo examine the dimensions of an array, we can ask for the shape,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe find that the shape of a is (1,4) or 1 row and 4 columns. Notice we have two options to execute the shape function:\n\nIn a.shape we return the attribute shape of the variable a.\nIn np.shape(a) we apply the function shape from numpy to the variable a.\n\nThe result is equivalent.\n\n\nExample 10. Sometimes we need to reset the workspace\nBy doing so, we get rid of all the variables. To do so, type %reset and enter y\n\n\nCode\n%reset\n\n\n\n\n\n\n\n\nQ. What command could we use to confirm there are no variables in the workspace?\nA. Consider who.\n\n\n\n\n\nCode\nwho\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe %reset command is an example of a magic. Magics are commands that start with the % symbol and use a language other than Python. They are only available in the notebook environment. In fact, the set of magics that is available is specific to the notebook kernel. This means that if you have a Jupyter notebook running a Ruby kernel the magics will be different.\n\n\n\n\nExample 11. We can define matrices in Python.\nA matrix is an array with more than one dimensio. Consider the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis creates a matrix with two rows and three columns. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Can you see the two rows and three columns?\n\n\n\nWe can manipulate matrices like we manipulate vectors.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 12. Indexing matrices and vectors.\nMatrices and vectors are arrays of numbers, and sometimes we want to access individual elements or small subsets of these lists. That’s easy to do in Python. Consider,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPython indexes from 0 (like C, C++, Java, and unlike MATLAB and Fortran which start at 1). To access the 2nd element of a or b, type a[1] / b[1]. We’ll be a bit fancier with our printing now to distinguish variables. Calling str(a) converts the variable a to a string that can be printed easily. Adding two strings just concatenates them: \"hi\" + \" bye\" = \"hi bye\".\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Do the results make sense? How would you access the 4th element of each vector?\n\n\n\nWe can combine a and b to form a matrix with a as the first row and b as the second. Note that we apply the function array() to the list [a,b], which it converts to a matrix.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo learn the size (or shape) of c we use shape():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe shape of c is [2 5]. It has two rows and five columns. To access the individual element in the 1st row and 4th column of c, type c[0,3]\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nWe access matrices using ‘row, column’ notation. So c[0,3] means print the element in row 0, column 3 of c.\n\n\n\n\n\n\n\nQ. How would you print all rows in the 2nd column of c?\n\n\n\n\n\nExample 13: We can find subsets of elements in matrices and vectors.\nOften we are interested in only some of the elements of a matrix or vector. For example, we might want to look at the data from a single experimental trial which is stored in a particular row of a matrix. Alternatively, we might want to find out when the values in a time series cross a given boundary. Doing this is simple in Python.\n\nSlicing\nSlicing means that we want to look at a specific portion of a vector or matrix, for example, the first row of a matrix. We will continue with the matrix c from the previous example. The notation ‘:’ means ‘all indices’. To access all columns in the entire first row of c, type c[0,:]. To access the 2nd thru 4th columns of the first row of c, type c[0,1:4].\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThe notation 1:4 means all integers from 1 up to, but not including 4, which in this case gives columns 1, 2, and 3.\n\nLeaving out the number before the colon tells Python to start at index 0. Leaving out the number after the colon tells Python to continue all the way to the end.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can also tell Python how to step through the indices. To access only the even columns of c, we can use the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis code tells Python to start at 0, continue to the end, and step by 2. The result should be the values in row 0, columns 0, 2, and 4 of c. We could write this explicitly as c[0,0:5:2].\n#### Selecting elements that satisfy a condition Sometimes we’re interested in locating particular values within a matrix or vector. As an example, let’s first define a vector.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Calculate the shape of a. What is the maximum value of a? Hint: Use the max() function.\n\n\n\nNow let’s find all values in a that exceed 10.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis is called logical indexing, let’s look at what a&gt;10 returns:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen we index a using this array lgIdx we get back only the entries in a corresponding to True, as above:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSometimes we want to know the actual indices in a where a &gt; 10. We can get them using the nonzero() array method, which returns the index of all entries that were True, or non-zero.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nThe command nonzero() can be used as both a function and a method. A method is called by adding it after the object it is meant to operate on with a period in between ( lgIdx.nonzero() ). A function is called with the argument explicitly provided inside the parentheses ( nonzero(lgIdx) ). Basically, a function and a method do the same thing, but a function needs to be given an argument, while a method assumes that the argument is the object that the method is attached to. Note that if we use nonzero() as a function, we need to tell it to look in NumPy for the definition (i.e. add `` at the beginning of the function call).\n\nNow we have another way to select the desired elements of a:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can use these two types of indexing to change subsets of the values of a.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How does a change in the first and second print statements?\n\n\n\nWe can perform these same logical operations for a matrix,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNotice that the last line collapses the True entries to an array, ordered by row and then by column. If you’ve used MATLAB, this is the opposite of what it does!\n\n\n\n\nExample 14: Plotting data in Python.\nIt’s not easy to look at lists of numbers and gain an intuitive feeling for their behavior, especially when the lists are long. In these cases, it’s better to visualize the lists of numbers by plotting them. Consider\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Looking at the values in ‘y’ printed above, can you tell what’s happending?\nA. Not really … let’s visualize y vs x instead.\n\n\n\n\nmatplotlib\nTo visualize y versus x let’s plot it. To do so, let’s first import some basic plotting routines from matplotlib, which provides a nice 2D plotting library. We’ll also tell Python to show matplotlib graphics inline, in this notebook.\nLet’s start by plotting a simple example for x and y,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does the plot above make sense for the variables x and y?\n\n\n\nNow, let’s go back to the definitions of x and y that we started this example with and plot y versus x.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe plot of x versus y should look a bit jagged, and not smooth like a sinusoid. To make the curve smoother, let’s redefine x as,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Compare this definition of x to the definition above. How do these two definitions differ?\n\n\n\n\n\n\n\n\n\nQ. What is the size of x? Does this make sense?\n\n\n\nNow let’s replot the sine function.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does this plot make sense, given your knowledge of x, y, and trigonometry?\n\n\n\n\n\n\nExample 15: What if we want to compare several functions?\nContinuing the example in the previous section, let’s define a second vector\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nand plot it:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’d now like to compare the two variables y and z. To do this, let’s plot both vectors on the same figure, label the axes, and provide a legend,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that we’ve included a third input to the function plot. Here the third input tells Python to draw the curve in a particular color: 'r' for red. There are many options we can use to plot; to see more, check out the documentation for plot.\nWe can also label the axes, give the figure a title, and provide a legend,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo futher edit this plot, you might decide - for example - that the font size for the labels is too small. We can change the default with:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 16: We can make random numbers in Python.\nTo generate a single Gaussian random number in Python, use the function in the NumPy random module.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLet’s generate a vector of 1000 Gaussian random numbers:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n… and look at a histogram of the vector:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Does this histogram make sense? Is it what you expect for a distribution of Gaussian random variables?\n\n\n\n\nSee Python Help (hist?) to learn about the function hist().\n\n\n\nExample 17: Repeating commands over and over and over . . .\nSometimes we’ll want to repeat the same command over and over again. For example, what if we want to plot sin(x + k*pi/4) where k varies from 1 to 5 in steps of 1; how do we do it? Consider the following:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThat’s horrible code! All I did was cut and paste the same thing four times. As a general rule, if you’re repeatedly cutting and pasting in code, what you’re doing is inefficient and typically error prone. There’s a much more elegant way to do this, and it involves making a for loop. Consider:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow let’s declare a for loop where k successively takes the values 1, then 2, then 3, …, up to 5. Note, any code we want to execute as part of the loop must be indented one level. The first line of code that is not indented, in this case show() below, executes after the for loop completes\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe small section of code above replaces all the cutting-and-pasting. Instead of cutting and pasting, we update the definition of y with different values of k and plot it within this for-loop.\n\n\n\n\n\n\nQ. Spend some time studying this for-loop. Does it make sense?\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nImportant: Python uses indentation to define for loops.\n\n\n\n\nExample 18: Defining a new function.\nWe’ve spent some time in this notebook writing and executing code. Sometimes we’ll need to write our own Python functions. Let’s do that now.\nOur function will do something very simple: it will take as input a vector and return as output the vector elements squared plus an additive constant.\nIf have a vector, v, and a constant, b, we would like to call:\nvsq = my_square_function(v, b)\nThis won’t work! We first need to define my_square_function. Let’s do so now,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe function begins with the keyword def followed by the function name and the inputs in parentheses. Notice that this first line ends with a colon :. All of the function components that follow this first line should be indented one level. This is just like the for loop we applied earlier; the operations performed by the for loop were indented one leve.\n\nWhen defining the function, the code the function executes should be indented one level.\n\nThe text inside triple quotes provides an optional documentation string that describes our function. While optional, including a ‘doc string’ is an important part of making your code understandable and reuseable.\nThe keyword return exits the function, and in this case returns the expression x * x + c. Note that a return statement with no arguments returns None, indicating the absence of a value.\nWith the function defined, let’s now call it. To do so we first define the inputs, and then run the function, as follows:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ. Try to make a function, my_power, so that y = power(x,n) evaluates \\(y = x^n\\), (in Python you can use x**n to take the power)\n\n\n\n\n\nExample 19: Load data into Python\nFor our last example let’s load a data file on the web in the .csv format into Python.\nTo do so, let’s first import the pandas module,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s load a data file using the function read_csv,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe variable df that holds the loaded data is a Python DataFrame. We can think of it as a simple table that holds our data.\nLet’s print it,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe see that the columns in the dataframe consist of two variables: d and t. Our collaborator who provided the data tells us that these correspond to the voltage recording (d) and a time axis (t) for her data.\nLet’s define variables to hold the data corresponding to each key,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nNote\n\n\n\nHere we convert the data in each column to a numpy array, because we’d (probably) like numpy to function on these values.\n\n\nNow, let’s plot the LFP data versus the time axis,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nExample 20: Compute statistics and compare\nContributed by @mateouma\nLet’s do some statistics. First, our standard imports.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWith numpy, we can find the mean and standard deviation of our LFP data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s use numpy to randomly generate numbers according to a normal distribution with the same mean and standard deviation as the LFP data. The syntax is np.random.normal(mean, sd, size), where mean, sd, and size are variables or numbers.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can use a histogram to compare the distribution of the data with a normal distribution with the same mean and standard deviation.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nAs we can see, our data doesn’t look normally distributed, but in practice we should use a statistical test to make this assessment."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BU MA665 + MA666 (Fall 2024)",
    "section": "",
    "text": "MA665\n\nIntroduction\n\nRead the syllabus\nRead: Wilson et al, Good enough practices in scientific computing, 2017\nRead: Riquelme and Gjorgjieva, Towards readable code in neuroscience, 2021\nCode: Set up Google Colab\nCode: Install Python via Anaconda\nCode: Set up ChatGPT\nPlease complete items in the Introduction to Python\nAdvanced: 100 numpy exercises\nAdvanced: Beautiful, Idiomatic Python\nAdvanced: Make a pull request to the Introduction notebook to add a new exercise. Be sure to use follow syntax in quarto with quarto-pyodide\n\n\n\nIntegrate & Fire Neuron\n\nRead: Abbott, Brain Res Bull, 1999.\nRead: Chapter 1, pages 5-12 @ C. Koch, Biophysics of computation, 1998.\nLecture Slides\nCode: Integrate & Fire Neuron in Python\n\n\n\nHodgkin-Huxley Neuron\n\nRead: Chapter 2, pages 25-42 @ E. Izhikevich, Dynamical Systems in Neuroscience, 2007.\nRead: Hodgkin-Huxley 1-page cheat sheet\nAdvanced: Hodgkin and Huxley, J Physiol, 1952.\nLecture Slides\nCode: Hodgkin-Huxley Neuron in Python\n\n\n\nPerceptron\n\nRead: Electronic Brain Teaches Itself, New York Times, 13 July 1958\nRead: Perceptron Tested for Photo Analysis, Aviation Weekly, 1961\nRead: Undercover Algorithm, O’Connor, 2022\nLecture Slides\nCode: Training a Perceptron in Python\n\n\n\nBackpropagation\n\nRead: Lee or Delusions of Artificail Intelligence, 2023\nWatch: Inside an artificial brain\nLecture Slides\nCode: Backpropagation in a Simple Neural Network in Python\n\n\n\nRegression\n\nRead: Chapter 3 of An Introduction to Statistical Learning (Free via BU Library)\nLecture Slides\nCode: Regression Example in Python\n\n\n\n\n\nMA666\n\nIntroduction to Rhythms\n\nRead: Jell-O Test Finds Lifelike Signals, New York Times, 6 March 1976\nRead: Neuronal Oscillations in Cortical Networks\nLecture 1 Slides\nLecture 2 Slides\nCode: Rhythms Introduction\n\n\n\nAnalyzing Rhythms"
  },
  {
    "objectID": "Backpropagation.html",
    "href": "Backpropagation.html",
    "title": "Backpropagation",
    "section": "",
    "text": "In this notebook, we’ll implement a quick representation of the backpropagation algorithm for the simple two node network.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nSteps to backpropagation\nWe outlined 4 steps to perform backpropagation,\n\nChoose random initial weights.\nTrain the neural network on given input and output data.\nUpdate the weights.\nRepeat steps 2 & 3 many times.\n\nLet’s now implement these steps in an example data set.\n\n\nLoad example data\nThe training data is backpropagation_example_data.csv. Get these data, and load them:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nHere we acquire two variables:\nin_true: the true input to the hidden two-node neural network\nout_true: the true output of the hidden two-ndoe neural network\nThe two-node neural network is hidden because we don’t know the weights (w[0], w[1], and w[2]).\nInstead, all we observe are the pairs of inputs and outputs to this hidden neural network.\nLet’s look at some of these data:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThese data were created by sending the inputs (in_true, the first column above) into a two-node neural network to produce the outputs (out_true, the second column above).\nAgain, we do not know the weights of this network … that’s what we’d like to find.\nTo do so, we’ll use these data to train a neural network through back propagation.\n\n\nFor training, first define two useful functions:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nNow, train the neural network with these (in_true, out_true) data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nChallenges\n\nUse the chain rule to verify the expression for \\(\\dfrac{dC}{dw_0} = (out-target)s_2(1-s_2) w_1 s_1 (1-s_1) s_0\\).\nComplete the code above to determine the weights (w[0] and w[1]) of the hidden two-node neural network."
  },
  {
    "objectID": "HH.html",
    "href": "HH.html",
    "title": "Hodgkin-Huxley Neuron",
    "section": "",
    "text": "In this notebook we will use Python to simulate the Hodgkin-Huxley (HH) neuron model. This model is arguably the most important computational model in neuroscience. We’ll focus here on simulating this model and understanding its pieces.\n\n1 Preliminaries\nBefore beginning, let’s load in the Python packages we’ll need:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn addition, let’s import the functions we’ll need to simulate the HH model, which are available on this repository:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n2 The Hodgkin-Huxley (HH) equation code.\nTo start, let’s examine the code for the HH model. To do so, visit the raw code avaiable here.\n\n\n\n\n\n\nQ: Examine this code. Can you make sense of it? Can you identify the gating variables? The rate functions? The equations that define the dynamics? We’ll answer these questions in this in notebook, but try so on your own first.\n\n\n\nWhenever examining code, it’s useful to consider the inputs to the code, and the outputs produced by the code. There are two inputs to HH0:\n\nI0 = the current we inject to the neuron.\nT0 = the total time of the simulation in [ms].\n\nAnd there are five outputs:\n\nV = the voltage of neuron.\nm = activation variable for Na-current.\nh = inactivation variable for Na-current.\nn = activation variable for K-current.\nt = the time axis of the simulation (useful for plotting).\n\n\n\n3 At low input current (I0), examine the HH dynamics.\nTo understand how the HH model works, we’ll start by focusing on the case when I0 is small. Let’s fix the input current to zero,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nand let’s simulate the model for 100 ms,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’ve now defined both inputs to the HH function, and can execute it, as follows,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that the function returns five outputs, which we assign to the variables V, m, h, n, and t.\n\n\n\n\n\n\nQ: What are the dynamics of the voltage (variable V) resulting from this simulation? HINT: Plot V vs t.\n\n\n\n\n\n\n\n\n\nQ: What are the dynamics of the gating variables (m, h, n) resulting from this simulation? HINT: Plot them!\n\n\n\n\n\n\n\n\n\nQ: What are the final values (after the 100 ms of simulation) of V, m, h, and n?\n\n\n\n\n\n4 At high input current (I0), examine the HH dynamics of a spike.\nLet’s now increase the input current to the HH model and get this model to generate repeated spiking activity. To do so, let’s set,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe can now simulate this model,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: What happens to the dynamics? HINT: Plot V vs t.\n\n\n\nObservations: You should have found that, at this value of input current, the model generates repeated spikes.\n\nLet’s now explore how the combined gates and dynamics evolve. To do so, let’s start by focusing our plot on a single spike. As a first step, let’s plot the voltage, and choose the time axis to focus on a single spike,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWe’ve now plotted the voltage dynamics for a single spike (and colored the curve black).\nLet’s now plot the three gating variables. To do so, we’ll make another plot.\nLet’s start by displaying the gating variable m over the same x-limits,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNotice that, in the call to plot we included the input label. This will be useful when we create a legend. Within this subplot, we can also simultaneously show the gating variables h and n, with the x-axis labeled.\nLet’s also add a legend to help us keep track of the different curves:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Using the figure you created above, describe how the gates swing open and closed during a spike.\n\n\n\nASIDE: Here’s a nice plotting trick, to link the x-axes of our two subfigures. Linking the axes is useful so that, when we zoom or move one subfigure, the other subfigure will match the x-axis.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, in the figure, you may use the pan/zoom tool to adjust the linked subplots.\n\n\n5 At high input current (I0), describe the dynamics of the conductances.\nWe have so far explored how the three gates m, h, and n evolve during a spike. By combining these terms, we can visualize how the conductances evolve during a spike. To do so, let’s stick with the simulation results we generated in the previous section, and focus our plot on a single spike,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, to plot the conductances, let’s define three new variables,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: Where do these terms come from?\n\n\n\nThen, let’s plot these conductances,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\nAt high input current (I0), describe the dynamics of the currents. In the previous section, we explored how the three conductances (gNa, gK, gL) evolve during a spike.\nLet’s now visualize how the ionic currents evolve during a spike.\nTo do so, let’s stick with the same settings used in the previous section and examine the same simulation result. Again, we’ll focus our plot on a single spike.\nNow, to plot the current, let’s define the new variables,\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\nQ: How do the conductances evolve during a spike?\n\n\n\n\n\n\n\n\n\nQ: You may notice a small, transient decrease in the sodium current INa near 47 ms. What causes this?\n\n\n\n\n\n6 Discussion\n\nHow is the HH model different from / similar to the IF and LIF models?\nWhat are the ion species simulated in the HH model?\nWhich ion species is fastest / slowest?\nHow many variables are in the HH model? Define each.\nSketch the model equations, in schematic form, to capture the “essence” of the behavior (don’t worry about the detailed values for parameters).\nWhich gating variables are depolarization activated / depolarization inactivated?\nSketch the steady-state curves for the gating variables.\nConsider the current: I_K=g_K n^4  (E_K-V)\n\nDefine each term.\nHow does this current behave for different values of V?\n\nConsider the current: I_Na=g_Na m^3 h (E_Na-V)\n\nDefine each term.\nHow does this current behave for different values of V?\n\n\n\n\n7 Challenges\n\nDescribe the dynamics during an action potential in the HH model. How does the voltage change? How do the gates open and close? How do the ions flow?\nDetermine how the firing rate of the HH model varies with input current I. Plot the firing rate versus I (i.e., plot the “f-I curve”).\nHow does the firing rate of the HH model change as you increase the potassium conductance? Provide a “simulation” explanation and a “physical” explanation.\nHow does the firing rate of the HH model change as you increase sodium conductance? Provide a “simulation” explanation and a “physical” explanation.\nBONUS: Use the forward and backward rate functions (\\(\\alpha\\) and \\(\\beta\\)) in the HH model (see code) to plot the steady state function and time constant for each channel (\\(m\\), \\(h\\), \\(n\\)) versus voltage. In other words, create Figure 1 in the Hodgkin-Huxley Cheat Sheet."
  }
]